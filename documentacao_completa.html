<!DOCTYPE html>
<html>
<head>
<title>documentacao_completa.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="documenta%C3%A7%C3%A3o-completa---ci%C3%AAncia-de-dados-com-python">Documentação Completa - Ciência de Dados com Python</h1>
<h2 id="%C3%ADndice">Índice</h2>
<ol>
<li><a href="#1-introdu%C3%A7%C3%A3o-%C3%A0-ci%C3%AAncia-de-dados">Introdução à Ciência de Dados</a></li>
<li><a href="#2-python-para-ci%C3%AAncia-de-dados">Python para Ciência de Dados</a></li>
<li><a href="#3-bibliotecas-essenciais">Bibliotecas Essenciais</a></li>
<li><a href="#4-manipula%C3%A7%C3%A3o-de-dados">Manipulação de Dados</a></li>
<li><a href="#5-visualiza%C3%A7%C3%A3o-de-dados">Visualização de Dados</a></li>
</ol>
<hr>
<h2 id="1-introdu%C3%A7%C3%A3o-%C3%A0-ci%C3%AAncia-de-dados">1. Introdução à Ciência de Dados</h2>
<h3 id="11-o-que-%C3%A9-ci%C3%AAncia-de-dados">1.1 O que é Ciência de Dados?</h3>
<p><strong>Definição:</strong> Ciência de Dados é uma disciplina interdisciplinar que combina estatística, programação, matemática e conhecimento de domínio para extrair insights significativos e conhecimento acionável de dados estruturados e não estruturados.</p>
<p><strong>Componentes Fundamentais:</strong></p>
<ol>
<li>
<p><strong>Estatística e Matemática</strong></p>
<ul>
<li>Base teórica para análise de dados</li>
<li>Inferência estatística e testes de hipóteses</li>
<li>Probabilidade e distribuições</li>
<li>Álgebra linear e cálculo</li>
</ul>
</li>
<li>
<p><strong>Programação</strong></p>
<ul>
<li>Automação de processos</li>
<li>Manipulação eficiente de dados</li>
<li>Implementação de algoritmos</li>
<li>Criação de pipelines de dados</li>
</ul>
</li>
<li>
<p><strong>Conhecimento de Domínio</strong></p>
<ul>
<li>Compreensão do contexto de negócio</li>
<li>Formulação de perguntas relevantes</li>
<li>Interpretação de resultados</li>
<li>Validação de insights</li>
</ul>
</li>
<li>
<p><strong>Visualização e Comunicação</strong></p>
<ul>
<li>Apresentação clara de resultados</li>
<li>Storytelling com dados</li>
<li>Dashboards e relatórios</li>
<li>Tradução técnica para não-técnicos</li>
</ul>
</li>
</ol>
<h3 id="12-tipos-de-dados">1.2 Tipos de Dados</h3>
<h4 id="dados-estruturados">Dados Estruturados</h4>
<p><strong>Definição:</strong> Dados organizados em formato tabular com esquema bem definido.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Organizados em linhas e colunas</li>
<li>Esquema fixo e predefinido</li>
<li>Fáceis de consultar com SQL</li>
<li>Armazenados em bancos de dados relacionais</li>
</ul>
<p><strong>Exemplos:</strong></p>
<ul>
<li>Planilhas Excel</li>
<li>Tabelas de bancos de dados</li>
<li>Arquivos CSV</li>
<li>Dados de sensores formatados</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Análises transacionais</li>
<li>Relatórios estruturados</li>
<li>Análises quantitativas</li>
<li>Séries temporais regulares</li>
</ul>
<h4 id="dados-n%C3%A3o-estruturados">Dados Não Estruturados</h4>
<p><strong>Definição:</strong> Dados sem formato predefinido ou esquema fixo.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Formato livre</li>
<li>Difíceis de processar com ferramentas tradicionais</li>
<li>Requerem técnicas especializadas de processamento</li>
<li>Volume geralmente maior</li>
</ul>
<p><strong>Exemplos:</strong></p>
<ul>
<li>Textos e documentos</li>
<li>Imagens e vídeos</li>
<li>Áudios e podcasts</li>
<li>Posts em redes sociais</li>
<li>E-mails</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Análise de sentimento</li>
<li>Reconhecimento de padrões</li>
<li>Processamento de linguagem natural</li>
<li>Visão computacional</li>
</ul>
<h4 id="dados-semi-estruturados">Dados Semi-estruturados</h4>
<p><strong>Definição:</strong> Dados com alguma organização, mas sem esquema rígido.</p>
<p><strong>Exemplos:</strong></p>
<ul>
<li>JSON</li>
<li>XML</li>
<li>NoSQL databases</li>
<li>Logs de sistema</li>
</ul>
<h3 id="13-o-pipeline-de-ci%C3%AAncia-de-dados">1.3 O Pipeline de Ciência de Dados</h3>
<pre class="hljs"><code><div>Definição do Problema → Coleta → Limpeza → Exploração →
Modelagem → Validação → Deploy → Monitoramento
</div></code></pre>
<h4 id="fase-1-defini%C3%A7%C3%A3o-do-problema">Fase 1: Definição do Problema</h4>
<p><strong>O que é:</strong> Estabelecer objetivos claros e mensuráveis para o projeto.</p>
<p><strong>Como fazer:</strong></p>
<ol>
<li>Identificar o problema de negócio</li>
<li>Traduzir em problema analítico</li>
<li>Definir métricas de sucesso</li>
<li>Estabelecer restrições e requisitos</li>
</ol>
<p><strong>Quando fazer:</strong></p>
<ul>
<li>Antes de iniciar qualquer análise</li>
<li>Ao receber nova demanda</li>
<li>Quando há mudanças no escopo</li>
</ul>
<p><strong>Perguntas chave:</strong></p>
<ul>
<li>Qual problema estamos tentando resolver?</li>
<li>Qual o impacto esperado?</li>
<li>Quais são as métricas de sucesso?</li>
<li>Quais dados estão disponíveis?</li>
</ul>
<h4 id="fase-2-coleta-de-dados">Fase 2: Coleta de Dados</h4>
<p><strong>O que é:</strong> Obtenção de dados relevantes de diversas fontes.</p>
<p><strong>Métodos de coleta:</strong></p>
<ol>
<li>
<p><strong>APIs (Application Programming Interfaces)</strong></p>
<ul>
<li><strong>Definição:</strong> Interfaces para acesso programático a dados</li>
<li><strong>Quando usar:</strong> Dados atualizados frequentemente, dados de terceiros</li>
<li><strong>Como usar:</strong> Requisições HTTP, autenticação, rate limits</li>
<li><strong>Exemplo:</strong> API do Twitter, Google Maps, dados financeiros</li>
</ul>
</li>
<li>
<p><strong>Web Scraping</strong></p>
<ul>
<li><strong>Definição:</strong> Extração automatizada de dados de websites</li>
<li><strong>Quando usar:</strong> Dados públicos não disponíveis via API</li>
<li><strong>Como usar:</strong> BeautifulSoup, Selenium, Scrapy</li>
<li><strong>Cuidados:</strong> Respeitar robots.txt, termos de uso, rate limiting</li>
</ul>
</li>
<li>
<p><strong>Bancos de Dados</strong></p>
<ul>
<li><strong>Definição:</strong> Sistemas organizados de armazenamento de dados</li>
<li><strong>Tipos:</strong> Relacionais (SQL), NoSQL, Data Warehouses</li>
<li><strong>Quando usar:</strong> Dados corporativos, transações, históricos</li>
<li><strong>Como usar:</strong> Queries SQL, ORM, conectores específicos</li>
</ul>
</li>
<li>
<p><strong>Arquivos</strong></p>
<ul>
<li><strong>Definição:</strong> Dados armazenados em formatos de arquivo</li>
<li><strong>Formatos comuns:</strong> CSV, Excel, JSON, Parquet, HDF5</li>
<li><strong>Quando usar:</strong> Dados estáticos, compartilhamento, backups</li>
<li><strong>Como usar:</strong> Pandas, readers específicos por formato</li>
</ul>
</li>
</ol>
<h4 id="fase-3-limpeza-de-dados">Fase 3: Limpeza de Dados</h4>
<p><strong>O que é:</strong> Processo de identificar e corrigir problemas nos dados para garantir qualidade e confiabilidade.</p>
<p><strong>Por que é importante:</strong></p>
<ul>
<li>80% do tempo de um projeto de dados é gasto em limpeza</li>
<li>Dados ruins levam a insights incorretos</li>
<li>&quot;Garbage in, garbage out&quot;</li>
</ul>
<p><strong>Problemas comuns:</strong></p>
<ol>
<li>
<p><strong>Valores Ausentes (Missing Values)</strong></p>
<p><strong>Definição:</strong> Dados faltantes em observações.</p>
<p><strong>Tipos:</strong></p>
<ul>
<li><strong>MCAR (Missing Completely At Random):</strong> Ausência aleatória</li>
<li><strong>MAR (Missing At Random):</strong> Ausência relacionada a outras variáveis</li>
<li><strong>MNAR (Missing Not At Random):</strong> Ausência relacionada ao próprio valor</li>
</ul>
<p><strong>Como tratar:</strong></p>
<ul>
<li>Remoção (quando poucos casos)</li>
<li>Imputação com média/mediana (dados numéricos)</li>
<li>Imputação com moda (dados categóricos)</li>
<li>Imputação avançada (KNN, regressão)</li>
<li>Criar flag de ausência</li>
</ul>
<p><strong>Quando usar cada método:</strong></p>
<ul>
<li><strong>Remoção:</strong> &lt; 5% de dados ausentes, MCAR</li>
<li><strong>Média/Mediana:</strong> Dados numéricos, distribuição simétrica</li>
<li><strong>Moda:</strong> Dados categóricos</li>
<li><strong>Avançada:</strong> Dados complexos, muitos ausentes</li>
</ul>
</li>
<li>
<p><strong>Duplicatas</strong></p>
<p><strong>Definição:</strong> Registros repetidos no dataset.</p>
<p><strong>Como identificar:</strong></p>
<ul>
<li>Verificar todas as colunas</li>
<li>Verificar subset de colunas chave</li>
<li>Considerar tolerância em valores numéricos</li>
</ul>
<p><strong>Como tratar:</strong></p>
<ul>
<li>Remover duplicatas exatas</li>
<li>Agregar duplicatas parciais</li>
<li>Investigar causa raiz</li>
</ul>
</li>
<li>
<p><strong>Outliers</strong></p>
<p><strong>Definição:</strong> Valores significativamente diferentes do padrão dos dados.</p>
<p><strong>Como identificar:</strong></p>
<ul>
<li>Método IQR (Interquartile Range)</li>
<li>Z-score (&gt; 3 ou &lt; -3)</li>
<li>Visualização (boxplot, scatter)</li>
<li>Isolation Forest</li>
</ul>
<p><strong>Como tratar:</strong></p>
<ul>
<li>Remover (se erro de medição)</li>
<li>Manter (se legítimo)</li>
<li>Transformar (winsorização, log transform)</li>
<li>Investigar separadamente</li>
</ul>
<p><strong>Quando remover:</strong></p>
<ul>
<li>Erros de entrada de dados</li>
<li>Erros de medição</li>
<li>Valores impossíveis</li>
</ul>
<p><strong>Quando manter:</strong></p>
<ul>
<li>Eventos raros mas legítimos</li>
<li>Interesse específico em extremos</li>
<li>Amostras pequenas</li>
</ul>
</li>
<li>
<p><strong>Inconsistências</strong></p>
<p><strong>Tipos:</strong></p>
<ul>
<li>Formatação (datas, números)</li>
<li>Nomenclatura (maiúsculas/minúsculas)</li>
<li>Unidades de medida</li>
<li>Codificação de categorias</li>
</ul>
<p><strong>Como tratar:</strong></p>
<ul>
<li>Padronização de formatos</li>
<li>Normalização de textos</li>
<li>Conversão de unidades</li>
<li>Mapeamento de categorias</li>
</ul>
</li>
</ol>
<h4 id="fase-4-explora%C3%A7%C3%A3o-de-dados-eda">Fase 4: Exploração de Dados (EDA)</h4>
<p><strong>O que é:</strong> Análise investigativa dos dados para descobrir padrões, anomalias e testar hipóteses.</p>
<p><strong>Objetivos:</strong></p>
<ol>
<li>Entender a estrutura dos dados</li>
<li>Identificar relações entre variáveis</li>
<li>Detectar padrões e tendências</li>
<li>Formular hipóteses</li>
<li>Validar suposições</li>
</ol>
<p><strong>Técnicas:</strong></p>
<ol>
<li>
<p><strong>Estatísticas Descritivas</strong></p>
<p><strong>Medidas de Tendência Central:</strong></p>
<ul>
<li>
<p><strong>Média:</strong> Soma dividida pelo número de observações</p>
<ul>
<li>Quando usar: Distribuição simétrica, sem outliers extremos</li>
<li>Limitação: Sensível a outliers</li>
</ul>
</li>
<li>
<p><strong>Mediana:</strong> Valor central quando dados ordenados</p>
<ul>
<li>Quando usar: Distribuição assimétrica, presença de outliers</li>
<li>Vantagem: Robusta a valores extremos</li>
</ul>
</li>
<li>
<p><strong>Moda:</strong> Valor mais frequente</p>
<ul>
<li>Quando usar: Dados categóricos, distribuições multimodais</li>
<li>Aplicação: Identificar padrões de comportamento</li>
</ul>
</li>
</ul>
<p><strong>Medidas de Dispersão:</strong></p>
<ul>
<li>
<p><strong>Variância:</strong> Média dos quadrados dos desvios</p>
<ul>
<li>Interpretação: Quão espalhados estão os dados</li>
<li>Unidade: Quadrado da unidade original</li>
</ul>
</li>
<li>
<p><strong>Desvio Padrão:</strong> Raiz quadrada da variância</p>
<ul>
<li>Vantagem: Mesma unidade dos dados</li>
<li>Interpretação: Distância média da média</li>
</ul>
</li>
<li>
<p><strong>Amplitude:</strong> Diferença entre máximo e mínimo</p>
<ul>
<li>Limitação: Sensível a outliers</li>
<li>Uso: Visão rápida do range</li>
</ul>
</li>
<li>
<p><strong>IQR (Interquartile Range):</strong> Q3 - Q1</p>
<ul>
<li>Vantagem: Robusto a outliers</li>
<li>Uso: Identificação de outliers</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Análise Univariada</strong></p>
<p><strong>Definição:</strong> Análise de uma variável por vez.</p>
<p><strong>Para variáveis numéricas:</strong></p>
<ul>
<li>Histogramas: Visualizar distribuição</li>
<li>Box plots: Identificar quartis e outliers</li>
<li>Density plots: Suavização da distribuição</li>
<li>Q-Q plots: Verificar normalidade</li>
</ul>
<p><strong>Para variáveis categóricas:</strong></p>
<ul>
<li>Tabelas de frequência</li>
<li>Gráficos de barras</li>
<li>Gráficos de pizza (usar com moderação)</li>
</ul>
</li>
<li>
<p><strong>Análise Bivariada</strong></p>
<p><strong>Definição:</strong> Análise da relação entre duas variáveis.</p>
<p><strong>Numérica vs Numérica:</strong></p>
<ul>
<li>Scatter plots: Visualizar relação</li>
<li>Correlação de Pearson: Relação linear</li>
<li>Correlação de Spearman: Relação monotônica</li>
</ul>
<p><strong>Categórica vs Numérica:</strong></p>
<ul>
<li>Box plots por categoria</li>
<li>Violin plots</li>
<li>Estatísticas por grupo</li>
</ul>
<p><strong>Categórica vs Categórica:</strong></p>
<ul>
<li>Tabelas de contingência</li>
<li>Heatmaps de frequência</li>
<li>Teste qui-quadrado</li>
</ul>
</li>
<li>
<p><strong>Análise Multivariada</strong></p>
<p><strong>Definição:</strong> Análise de múltiplas variáveis simultaneamente.</p>
<p><strong>Técnicas:</strong></p>
<ul>
<li>Matriz de correlação</li>
<li>Pair plots</li>
<li>PCA (Principal Component Analysis)</li>
<li>Cluster analysis</li>
</ul>
</li>
</ol>
<h4 id="fase-5-modelagem">Fase 5: Modelagem</h4>
<p><strong>O que é:</strong> Aplicação de algoritmos para aprender padrões dos dados e fazer predições.</p>
<p><strong>Tipos de problemas:</strong></p>
<ol>
<li>
<p><strong>Supervisionado</strong></p>
<ul>
<li><strong>Definição:</strong> Aprendizado com dados rotulados</li>
<li><strong>Quando usar:</strong> Temos exemplos de entrada e saída</li>
</ul>
<p><strong>Subtipos:</strong></p>
<ul>
<li>
<p><strong>Classificação:</strong> Predizer categoria</p>
<ul>
<li>Binária: Sim/Não, Spam/Ham</li>
<li>Multiclasse: Tipo de produto, sentimento</li>
</ul>
</li>
<li>
<p><strong>Regressão:</strong> Predizer valor contínuo</p>
<ul>
<li>Linear: Relação linear</li>
<li>Não-linear: Relações complexas</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Não Supervisionado</strong></p>
<ul>
<li><strong>Definição:</strong> Aprendizado sem rótulos</li>
<li><strong>Quando usar:</strong> Descobrir estruturas ocultas</li>
</ul>
<p><strong>Subtipos:</strong></p>
<ul>
<li><strong>Clustering:</strong> Agrupar observações similares</li>
<li><strong>Redução de dimensionalidade:</strong> Simplificar dados</li>
<li><strong>Detecção de anomalias:</strong> Identificar padrões incomuns</li>
</ul>
</li>
<li>
<p><strong>Semi-supervisionado</strong></p>
<ul>
<li><strong>Definição:</strong> Combinação de dados rotulados e não rotulados</li>
<li><strong>Quando usar:</strong> Poucos dados rotulados disponíveis</li>
</ul>
</li>
</ol>
<h4 id="fase-6-valida%C3%A7%C3%A3o">Fase 6: Validação</h4>
<p><strong>O que é:</strong> Avaliação do desempenho e confiabilidade do modelo.</p>
<p><strong>Técnicas:</strong></p>
<ol>
<li>
<p><strong>Holdout Method</strong></p>
<ul>
<li>Dividir dados em treino e teste</li>
<li>Simples e rápido</li>
<li>Pode ser instável com amostras pequenas</li>
</ul>
</li>
<li>
<p><strong>Cross-Validation</strong></p>
<ul>
<li>K-Fold: Dividir em K partes</li>
<li>Mais robusto que holdout</li>
<li>Maior custo computacional</li>
</ul>
</li>
<li>
<p><strong>Métricas de Avaliação</strong></p>
<p><strong>Classificação:</strong></p>
<ul>
<li>Acurácia, Precisão, Recall, F1-Score</li>
<li>Matriz de confusão</li>
<li>ROC-AUC</li>
</ul>
<p><strong>Regressão:</strong></p>
<ul>
<li>MAE, MSE, RMSE</li>
<li>R², R² Ajustado</li>
<li>MAPE</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-python-para-ci%C3%AAncia-de-dados">2. Python para Ciência de Dados</h2>
<h3 id="21-por-que-python">2.1 Por que Python?</h3>
<p><strong>Vantagens:</strong></p>
<ol>
<li>
<p><strong>Sintaxe Clara e Intuitiva</strong></p>
<ul>
<li>Código legível como pseudocódigo</li>
<li>Curva de aprendizado suave</li>
<li>Manutenção facilitada</li>
</ul>
</li>
<li>
<p><strong>Ecossistema Rico</strong></p>
<ul>
<li>Mais de 300.000 pacotes no PyPI</li>
<li>Bibliotecas especializadas para cada tarefa</li>
<li>Integração entre ferramentas</li>
</ul>
</li>
<li>
<p><strong>Comunidade Ativa</strong></p>
<ul>
<li>Grande base de usuários</li>
<li>Suporte em fóruns e comunidades</li>
<li>Documentação extensa</li>
<li>Tutoriais e cursos abundantes</li>
</ul>
</li>
<li>
<p><strong>Versatilidade</strong></p>
<ul>
<li>Prototipação rápida</li>
<li>Produção escalável</li>
<li>Integração com outras linguagens</li>
<li>Deploy em diversas plataformas</li>
</ul>
</li>
<li>
<p><strong>Gratuito e Open Source</strong></p>
<ul>
<li>Sem custos de licença</li>
<li>Código-fonte disponível</li>
<li>Modificável conforme necessidade</li>
</ul>
</li>
</ol>
<h3 id="22-estruturas-de-dados-fundamentais">2.2 Estruturas de Dados Fundamentais</h3>
<h4 id="listas">Listas</h4>
<p><strong>Definição:</strong> Coleção ordenada e mutável de elementos.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Ordenada: Mantém ordem de inserção</li>
<li>Mutável: Pode ser modificada após criação</li>
<li>Heterogênea: Pode conter diferentes tipos</li>
<li>Indexada: Acesso por posição (0-based)</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Armazenar sequências de elementos</li>
<li>Ordem importa</li>
<li>Necessidade de modificação</li>
<li>Elementos duplicados são permitidos</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Criação</span>
lista = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
lista_mista = [<span class="hljs-number">1</span>, <span class="hljs-string">"texto"</span>, <span class="hljs-number">3.14</span>, <span class="hljs-literal">True</span>]

<span class="hljs-comment"># Acesso</span>
primeiro = lista[<span class="hljs-number">0</span>]      <span class="hljs-comment"># Primeiro elemento</span>
ultimo = lista[<span class="hljs-number">-1</span>]       <span class="hljs-comment"># Último elemento</span>
fatiamento = lista[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]  <span class="hljs-comment"># Elementos de índice 1 a 3</span>

<span class="hljs-comment"># Modificação</span>
lista.append(<span class="hljs-number">6</span>)          <span class="hljs-comment"># Adicionar ao final</span>
lista.insert(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)       <span class="hljs-comment"># Inserir em posição</span>
lista.remove(<span class="hljs-number">3</span>)          <span class="hljs-comment"># Remover elemento</span>
lista.pop()              <span class="hljs-comment"># Remover e retornar último</span>

<span class="hljs-comment"># Operações</span>
tamanho = len(lista)     <span class="hljs-comment"># Comprimento</span>
existe = <span class="hljs-number">3</span> <span class="hljs-keyword">in</span> lista      <span class="hljs-comment"># Verificar existência</span>
lista.sort()             <span class="hljs-comment"># Ordenar in-place</span>
nova = sorted(lista)     <span class="hljs-comment"># Retornar lista ordenada</span>
</div></code></pre>
<p><strong>List Comprehension:</strong></p>
<p><strong>Definição:</strong> Forma concisa de criar listas baseadas em iterações.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Transformar elementos de uma lista</li>
<li>Filtrar elementos</li>
<li>Criar listas de forma mais legível</li>
</ul>
<p><strong>Sintaxe:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Forma básica</span>
[expressão <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterável]

<span class="hljs-comment"># Com condição</span>
[expressão <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterável <span class="hljs-keyword">if</span> condição]

<span class="hljs-comment"># Aninhada</span>
[expressão <span class="hljs-keyword">for</span> item1 <span class="hljs-keyword">in</span> iterável1 <span class="hljs-keyword">for</span> item2 <span class="hljs-keyword">in</span> iterável2]
</div></code></pre>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Quadrados de 0 a 9</span>
quadrados = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]

<span class="hljs-comment"># Números pares</span>
pares = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]

<span class="hljs-comment"># Matriz</span>
matriz = [[i*j <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]

<span class="hljs-comment"># Processar strings</span>
nomes = [<span class="hljs-string">"alice"</span>, <span class="hljs-string">"bob"</span>, <span class="hljs-string">"charlie"</span>]
maiusculas = [nome.upper() <span class="hljs-keyword">for</span> nome <span class="hljs-keyword">in</span> nomes]
</div></code></pre>
<h4 id="tuplas">Tuplas</h4>
<p><strong>Definição:</strong> Coleção ordenada e imutável de elementos.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Ordenada: Mantém ordem</li>
<li>Imutável: Não pode ser modificada</li>
<li>Heterogênea: Diferentes tipos</li>
<li>Hashable: Pode ser chave de dicionário</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados que não devem mudar</li>
<li>Retornar múltiplos valores de função</li>
<li>Chaves de dicionário</li>
<li>Melhor performance que listas (imutável)</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Criação</span>
tupla = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
coordenada = (<span class="hljs-number">10.5</span>, <span class="hljs-number">20.3</span>)
single = (<span class="hljs-number">1</span>,)  <span class="hljs-comment"># Note a vírgula</span>

<span class="hljs-comment"># Unpacking</span>
x, y = coordenada
a, b, c = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
primeiro, *resto = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)

<span class="hljs-comment"># Acesso</span>
elemento = tupla[<span class="hljs-number">0</span>]
fatia = tupla[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]

<span class="hljs-comment"># Operações</span>
tamanho = len(tupla)
concatenada = tupla + (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
repetida = tupla * <span class="hljs-number">3</span>
</div></code></pre>
<p><strong>Quando usar tupla vs lista:</strong></p>
<ul>
<li><strong>Tupla:</strong> Dados imutáveis, coordenadas, configurações, chaves</li>
<li><strong>Lista:</strong> Dados mutáveis, coleções dinâmicas, necessidade de ordenação</li>
</ul>
<h4 id="dicion%C3%A1rios">Dicionários</h4>
<p><strong>Definição:</strong> Coleção de pares chave-valor, não ordenada (Python 3.7+ mantém ordem de inserção).</p>
<p><strong>Características:</strong></p>
<ul>
<li>Mutável: Pode ser modificado</li>
<li>Chaves únicas: Não permite duplicatas</li>
<li>Acesso rápido: O(1) em média</li>
<li>Chaves hashable: Imutáveis (string, número, tupla)</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Mapear relacionamentos chave-valor</li>
<li>Lookup rápido</li>
<li>Contagem de frequências</li>
<li>Configurações e parâmetros</li>
<li>Armazenar dados estruturados</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Criação</span>
pessoa = {
    <span class="hljs-string">'nome'</span>: <span class="hljs-string">'Ana'</span>,
    <span class="hljs-string">'idade'</span>: <span class="hljs-number">28</span>,
    <span class="hljs-string">'cidade'</span>: <span class="hljs-string">'São Paulo'</span>
}

<span class="hljs-comment"># Acesso</span>
nome = pessoa[<span class="hljs-string">'nome'</span>]           <span class="hljs-comment"># Erro se não existir</span>
idade = pessoa.get(<span class="hljs-string">'idade'</span>)     <span class="hljs-comment"># None se não existir</span>
idade = pessoa.get(<span class="hljs-string">'peso'</span>, <span class="hljs-number">0</span>)   <span class="hljs-comment"># Valor padrão</span>

<span class="hljs-comment"># Modificação</span>
pessoa[<span class="hljs-string">'email'</span>] = <span class="hljs-string">'ana@email.com'</span>  <span class="hljs-comment"># Adicionar/modificar</span>
<span class="hljs-keyword">del</span> pessoa[<span class="hljs-string">'cidade'</span>]                <span class="hljs-comment"># Remover</span>
removido = pessoa.pop(<span class="hljs-string">'idade'</span>)      <span class="hljs-comment"># Remover e retornar</span>

<span class="hljs-comment"># Operações</span>
chaves = pessoa.keys()
valores = pessoa.values()
itens = pessoa.items()
existe = <span class="hljs-string">'nome'</span> <span class="hljs-keyword">in</span> pessoa

<span class="hljs-comment"># Iteração</span>
<span class="hljs-keyword">for</span> chave <span class="hljs-keyword">in</span> pessoa:
    print(chave, pessoa[chave])

<span class="hljs-keyword">for</span> chave, valor <span class="hljs-keyword">in</span> pessoa.items():
    print(<span class="hljs-string">f"<span class="hljs-subst">{chave}</span>: <span class="hljs-subst">{valor}</span>"</span>)
</div></code></pre>
<p><strong>Dict Comprehension:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Criar dicionário</span>
quadrados = {x: x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)}

<span class="hljs-comment"># Inverter dicionário</span>
invertido = {v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> original.items()}

<span class="hljs-comment"># Filtrar</span>
maiores = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> dados.items() <span class="hljs-keyword">if</span> v &gt; <span class="hljs-number">10</span>}
</div></code></pre>
<h4 id="sets-conjuntos">Sets (Conjuntos)</h4>
<p><strong>Definição:</strong> Coleção não ordenada de elementos únicos.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Não ordenado: Sem índice</li>
<li>Elementos únicos: Remove duplicatas automaticamente</li>
<li>Mutável: Pode adicionar/remover</li>
<li>Elementos hashable: Imutáveis</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Remover duplicatas</li>
<li>Testes de pertinência rápidos</li>
<li>Operações de conjunto (união, interseção)</li>
<li>Quando ordem não importa</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Criação</span>
conjunto = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
vazio = set()  <span class="hljs-comment"># {} cria dicionário vazio</span>
de_lista = set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment"># {1, 2, 3}</span>

<span class="hljs-comment"># Operações de conjunto</span>
a = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
b = {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>}

uniao = a | b              <span class="hljs-comment"># {1, 2, 3, 4, 5, 6}</span>
intersecao = a &amp; b         <span class="hljs-comment"># {3, 4}</span>
diferenca = a - b          <span class="hljs-comment"># {1, 2}</span>
diff_simetrica = a ^ b     <span class="hljs-comment"># {1, 2, 5, 6}</span>

<span class="hljs-comment"># Modificação</span>
conjunto.add(<span class="hljs-number">6</span>)
conjunto.remove(<span class="hljs-number">3</span>)         <span class="hljs-comment"># Erro se não existir</span>
conjunto.discard(<span class="hljs-number">3</span>)        <span class="hljs-comment"># Sem erro</span>
conjunto.clear()

<span class="hljs-comment"># Testes</span>
existe = <span class="hljs-number">3</span> <span class="hljs-keyword">in</span> conjunto
subconjunto = a &lt;= b
superconjunto = a &gt;= b
</div></code></pre>
<h3 id="23-fun%C3%A7%C3%B5es">2.3 Funções</h3>
<p><strong>Definição:</strong> Bloco de código reutilizável que realiza uma tarefa específica.</p>
<p><strong>Por que usar funções:</strong></p>
<ol>
<li><strong>Reutilização:</strong> Evitar repetição de código</li>
<li><strong>Modularização:</strong> Dividir problemas complexos</li>
<li><strong>Manutenção:</strong> Facilitar alterações</li>
<li><strong>Legibilidade:</strong> Código mais claro</li>
<li><strong>Testabilidade:</strong> Facilitar testes</li>
</ol>
<p><strong>Estrutura básica:</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nome_da_funcao</span><span class="hljs-params">(parametros)</span>:</span>
    <span class="hljs-string">"""
    Docstring: Descreve o que a função faz
    """</span>
    <span class="hljs-comment"># Corpo da função</span>
    <span class="hljs-keyword">return</span> resultado
</div></code></pre>
<p><strong>Tipos de argumentos:</strong></p>
<ol>
<li><strong>Posicionais:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">somar</span><span class="hljs-params">(a, b)</span>:</span>
    <span class="hljs-keyword">return</span> a + b

resultado = somar(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># a=5, b=3</span>
</div></code></pre>
<ol start="2">
<li><strong>Nomeados (Keyword):</strong></li>
</ol>
<pre class="hljs"><code><div>resultado = somar(a=<span class="hljs-number">5</span>, b=<span class="hljs-number">3</span>)
resultado = somar(b=<span class="hljs-number">3</span>, a=<span class="hljs-number">5</span>)  <span class="hljs-comment"># Ordem não importa</span>
</div></code></pre>
<ol start="3">
<li><strong>Padrão:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">saudar</span><span class="hljs-params">(nome, saudacao=<span class="hljs-string">"Olá"</span>)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f"<span class="hljs-subst">{saudacao}</span>, <span class="hljs-subst">{nome}</span>!"</span>

print(saudar(<span class="hljs-string">"Ana"</span>))              <span class="hljs-comment"># Usa padrão</span>
print(saudar(<span class="hljs-string">"Ana"</span>, <span class="hljs-string">"Bom dia"</span>))  <span class="hljs-comment"># Sobrescreve</span>
</div></code></pre>
<ol start="4">
<li><strong>Args variáveis:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">somar_todos</span><span class="hljs-params">(*numeros)</span>:</span>
    <span class="hljs-keyword">return</span> sum(numeros)

total = somar_todos(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)
</div></code></pre>
<ol start="5">
<li><strong>Kwargs variáveis:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">criar_perfil</span><span class="hljs-params">(**dados)</span>:</span>
    <span class="hljs-keyword">for</span> chave, valor <span class="hljs-keyword">in</span> dados.items():
        print(<span class="hljs-string">f"<span class="hljs-subst">{chave}</span>: <span class="hljs-subst">{valor}</span>"</span>)

criar_perfil(nome=<span class="hljs-string">"Ana"</span>, idade=<span class="hljs-number">28</span>, cidade=<span class="hljs-string">"SP"</span>)
</div></code></pre>
<p><strong>Funções Lambda:</strong></p>
<p><strong>Definição:</strong> Funções anônimas de uma linha.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Funções simples e curtas</li>
<li>Uso com map, filter, reduce</li>
<li>Callbacks</li>
<li>Quando não precisa de nome</li>
</ul>
<p><strong>Sintaxe:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">lambda</span> argumentos: expressão
</div></code></pre>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Função simples</span>
dobro = <span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>
print(dobro(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 10</span>

<span class="hljs-comment"># Múltiplos argumentos</span>
soma = <span class="hljs-keyword">lambda</span> a, b: a + b
print(soma(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment"># 7</span>

<span class="hljs-comment"># Com map</span>
numeros = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
dobrados = list(map(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>, numeros))

<span class="hljs-comment"># Com filter</span>
pares = list(filter(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, numeros))

<span class="hljs-comment"># Com sorted</span>
pessoas = [(<span class="hljs-string">'Ana'</span>, <span class="hljs-number">25</span>), (<span class="hljs-string">'Bruno'</span>, <span class="hljs-number">30</span>), (<span class="hljs-string">'Carlos'</span>, <span class="hljs-number">20</span>)]
ordenado = sorted(pessoas, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])
</div></code></pre>
<p><strong>Quando NÃO usar lambda:</strong></p>
<ul>
<li>Lógica complexa</li>
<li>Múltiplas linhas</li>
<li>Necessidade de documentação</li>
<li>Reutilização em vários lugares</li>
</ul>
<h3 id="24-programa%C3%A7%C3%A3o-funcional">2.4 Programação Funcional</h3>
<p><strong>Map:</strong></p>
<p><strong>Definição:</strong> Aplica uma função a cada elemento de um iterável.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Transformar todos os elementos</li>
<li>Aplicar mesma operação em lista</li>
<li>Alternativa a list comprehension</li>
</ul>
<p><strong>Sintaxe:</strong></p>
<pre class="hljs"><code><div>map(funcao, iteravel)
</div></code></pre>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Elevar ao quadrado</span>
numeros = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
quadrados = list(map(<span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>, numeros))

<span class="hljs-comment"># Converter para maiúsculas</span>
nomes = [<span class="hljs-string">"ana"</span>, <span class="hljs-string">"bruno"</span>, <span class="hljs-string">"carlos"</span>]
maiusculas = list(map(str.upper, nomes))

<span class="hljs-comment"># Múltiplos iteráveis</span>
a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
b = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]
soma = list(map(<span class="hljs-keyword">lambda</span> x, y: x + y, a, b))
</div></code></pre>
<p><strong>Filter:</strong></p>
<p><strong>Definição:</strong> Filtra elementos baseado em condição.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Selecionar elementos que atendem critério</li>
<li>Remover elementos indesejados</li>
<li>Alternativa a list comprehension com if</li>
</ul>
<p><strong>Sintaxe:</strong></p>
<pre class="hljs"><code><div>filter(funcao, iteravel)
</div></code></pre>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Números pares</span>
numeros = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]
pares = list(filter(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, numeros))

<span class="hljs-comment"># Strings não vazias</span>
palavras = [<span class="hljs-string">""</span>, <span class="hljs-string">"python"</span>, <span class="hljs-string">""</span>, <span class="hljs-string">"data"</span>, <span class="hljs-string">"science"</span>]
nao_vazias = list(filter(<span class="hljs-literal">None</span>, palavras))

<span class="hljs-comment"># Filtrar por condição complexa</span>
pessoas = [
    {<span class="hljs-string">'nome'</span>: <span class="hljs-string">'Ana'</span>, <span class="hljs-string">'idade'</span>: <span class="hljs-number">25</span>},
    {<span class="hljs-string">'nome'</span>: <span class="hljs-string">'Bruno'</span>, <span class="hljs-string">'idade'</span>: <span class="hljs-number">30</span>},
    {<span class="hljs-string">'nome'</span>: <span class="hljs-string">'Carlos'</span>, <span class="hljs-string">'idade'</span>: <span class="hljs-number">20</span>}
]
maiores_25 = list(filter(<span class="hljs-keyword">lambda</span> p: p[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">25</span>, pessoas))
</div></code></pre>
<p><strong>Reduce:</strong></p>
<p><strong>Definição:</strong> Aplica função de forma cumulativa aos elementos.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Agregar elementos em único valor</li>
<li>Cálculos acumulativos</li>
<li>Implementar operações complexas</li>
</ul>
<p><strong>Sintaxe:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce
reduce(funcao, iteravel, inicial)
</div></code></pre>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce

<span class="hljs-comment"># Somar todos</span>
numeros = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
soma = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, numeros)  <span class="hljs-comment"># 15</span>

<span class="hljs-comment"># Produto</span>
produto = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, numeros)  <span class="hljs-comment"># 120</span>

<span class="hljs-comment"># Máximo</span>
maximo = reduce(<span class="hljs-keyword">lambda</span> x, y: x <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">else</span> y, numeros)

<span class="hljs-comment"># Concatenar strings</span>
palavras = [<span class="hljs-string">"Python"</span>, <span class="hljs-string">"é"</span>, <span class="hljs-string">"incrível"</span>]
frase = reduce(<span class="hljs-keyword">lambda</span> x, y: x + <span class="hljs-string">" "</span> + y, palavras)
</div></code></pre>
<hr>
<h2 id="3-bibliotecas-essenciais">3. Bibliotecas Essenciais</h2>
<h3 id="31-numpy---computa%C3%A7%C3%A3o-num%C3%A9rica">3.1 NumPy - Computação Numérica</h3>
<p><strong>Definição:</strong> Biblioteca fundamental para computação científica em Python, fornecendo arrays multidimensionais eficientes e funções matemáticas.</p>
<p><strong>Por que NumPy é importante:</strong></p>
<ol>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Implementado em C</li>
<li>10-100x mais rápido que listas Python</li>
<li>Operações vetorizadas</li>
</ul>
</li>
<li>
<p><strong>Eficiência de memória</strong></p>
<ul>
<li>Arrays são contíguos na memória</li>
<li>Menor overhead que listas</li>
<li>Tipos de dados específicos</li>
</ul>
</li>
<li>
<p><strong>Funcionalidade</strong></p>
<ul>
<li>Álgebra linear</li>
<li>Transformadas de Fourier</li>
<li>Números aleatórios</li>
<li>Operações estatísticas</li>
</ul>
</li>
</ol>
<p><strong>Quando usar NumPy:</strong></p>
<ul>
<li>Operações matemáticas em arrays</li>
<li>Processamento de dados numéricos</li>
<li>Base para outras bibliotecas (Pandas, Scikit-learn)</li>
<li>Quando performance é crítica</li>
</ul>
<p><strong>Arrays NumPy vs Listas Python:</strong></p>
<table>
<thead>
<tr>
<th>Característica</th>
<th>NumPy Array</th>
<th>Lista Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>Velocidade</td>
<td>Muito rápido</td>
<td>Lento</td>
</tr>
<tr>
<td>Memória</td>
<td>Eficiente</td>
<td>Maior overhead</td>
</tr>
<tr>
<td>Tipo de dados</td>
<td>Homogêneo</td>
<td>Heterogêneo</td>
</tr>
<tr>
<td>Operações</td>
<td>Vetorizadas</td>
<td>Loop necessário</td>
</tr>
<tr>
<td>Dimensões</td>
<td>Multidimensional</td>
<td>1D (nested para mais)</td>
</tr>
</tbody>
</table>
<p><strong>Conceitos fundamentais:</strong></p>
<h4 id="ndarray-n-dimensional-array">ndarray (N-dimensional array)</h4>
<p><strong>Definição:</strong> Estrutura de dados central do NumPy, array multidimensional homogêneo.</p>
<p><strong>Atributos importantes:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])

arr.shape      <span class="hljs-comment"># (2, 3) - dimensões</span>
arr.ndim       <span class="hljs-comment"># 2 - número de dimensões</span>
arr.size       <span class="hljs-comment"># 6 - total de elementos</span>
arr.dtype      <span class="hljs-comment"># dtype('int64') - tipo de dados</span>
arr.itemsize   <span class="hljs-comment"># 8 - tamanho em bytes de cada elemento</span>
</div></code></pre>
<p><strong>Criação de arrays:</strong></p>
<ol>
<li><strong>A partir de listas:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment"># 1D</span>
arr1d = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])

<span class="hljs-comment"># 2D</span>
arr2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])

<span class="hljs-comment"># 3D</span>
arr3d = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]], [[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]]])
</div></code></pre>
<ol start="2">
<li><strong>Arrays especiais:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment"># Zeros</span>
zeros = np.zeros((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))           <span class="hljs-comment"># Array 3x4 de zeros</span>
zeros_like = np.zeros_like(arr)    <span class="hljs-comment"># Mesmo shape que arr</span>

<span class="hljs-comment"># Uns</span>
ones = np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))             <span class="hljs-comment"># Array 2x3 de uns</span>
ones_like = np.ones_like(arr)

<span class="hljs-comment"># Identidade</span>
identidade = np.eye(<span class="hljs-number">4</span>)             <span class="hljs-comment"># Matriz identidade 4x4</span>
diagonal = np.identity(<span class="hljs-number">3</span>)          <span class="hljs-comment"># Mesma coisa</span>

<span class="hljs-comment"># Vazio (não inicializado)</span>
vazio = np.empty((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))           <span class="hljs-comment"># Valores aleatórios da memória</span>

<span class="hljs-comment"># Constante</span>
constante = np.full((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), <span class="hljs-number">7</span>)     <span class="hljs-comment"># Array 3x3 preenchido com 7</span>
</div></code></pre>
<ol start="3">
<li><strong>Sequências:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment"># Range</span>
arange = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)       <span class="hljs-comment"># [0, 2, 4, 6, 8]</span>
arange_float = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>)

<span class="hljs-comment"># Espaçamento linear</span>
linspace = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>)    <span class="hljs-comment"># 5 valores entre 0 e 1</span>
<span class="hljs-comment"># [0.  , 0.25, 0.5 , 0.75, 1.  ]</span>

<span class="hljs-comment"># Espaçamento logarítmico</span>
logspace = np.logspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>)    <span class="hljs-comment"># 5 valores de 10^0 a 10^2</span>
</div></code></pre>
<ol start="4">
<li><strong>Arrays aleatórios:</strong></li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment"># Uniforme [0, 1)</span>
uniform = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment"># Normal padrão</span>
normal = np.random.randn(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)

<span class="hljs-comment"># Inteiros aleatórios</span>
integers = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))

<span class="hljs-comment"># Escolha aleatória</span>
choice = np.random.choice([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], size=<span class="hljs-number">10</span>)

<span class="hljs-comment"># Seed para reproducibilidade</span>
np.random.seed(<span class="hljs-number">42</span>)
</div></code></pre>
<h4 id="opera%C3%A7%C3%B5es-vetorizadas">Operações Vetorizadas</h4>
<p><strong>Definição:</strong> Operações aplicadas elemento a elemento sem loops explícitos.</p>
<p><strong>Por que são importantes:</strong></p>
<ul>
<li>Muito mais rápidas que loops Python</li>
<li>Código mais conciso e legível</li>
<li>Aproveitam otimizações de baixo nível</li>
</ul>
<p><strong>Operações básicas:</strong></p>
<pre class="hljs"><code><div>a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])
b = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])

<span class="hljs-comment"># Aritméticas</span>
soma = a + b          <span class="hljs-comment"># [11, 22, 33, 44, 55]</span>
diferenca = a - b     <span class="hljs-comment"># [-9, -18, -27, -36, -45]</span>
produto = a * b       <span class="hljs-comment"># [10, 40, 90, 160, 250]</span>
divisao = b / a       <span class="hljs-comment"># [10, 10, 10, 10, 10]</span>
potencia = a ** <span class="hljs-number">2</span>     <span class="hljs-comment"># [1, 4, 9, 16, 25]</span>

<span class="hljs-comment"># Com escalares</span>
multiplicado = a * <span class="hljs-number">2</span>  <span class="hljs-comment"># [2, 4, 6, 8, 10]</span>
somado = a + <span class="hljs-number">10</span>       <span class="hljs-comment"># [11, 12, 13, 14, 15]</span>

<span class="hljs-comment"># Comparações</span>
maior = a &gt; <span class="hljs-number">3</span>         <span class="hljs-comment"># [False, False, False, True, True]</span>
igual = a == <span class="hljs-number">3</span>        <span class="hljs-comment"># [False, False, True, False, False]</span>
</div></code></pre>
<p><strong>Broadcasting:</strong></p>
<p><strong>Definição:</strong> Mecanismo que permite operações entre arrays de shapes diferentes.</p>
<p><strong>Regras:</strong></p>
<ol>
<li>Se arrays têm diferentes números de dimensões, o de menor dimensão é preenchido com 1s à esquerda</li>
<li>Arrays são compatíveis em uma dimensão se forem iguais ou um deles for 1</li>
<li>Após broadcasting, cada array se comporta como se tivesse o shape máximo</li>
</ol>
<p><strong>Exemplos:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Escalar com array</span>
a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
b = <span class="hljs-number">2</span>
resultado = a * b  <span class="hljs-comment"># [2, 4, 6]</span>

<span class="hljs-comment"># 1D com 2D</span>
a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])        <span class="hljs-comment"># shape (3,)</span>
b = np.array([[<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [<span class="hljs-number">3</span>]])  <span class="hljs-comment"># shape (3, 1)</span>
resultado = a + b              <span class="hljs-comment"># shape (3, 3)</span>
<span class="hljs-comment"># [[2, 3, 4],</span>
<span class="hljs-comment">#  [3, 4, 5],</span>
<span class="hljs-comment">#  [4, 5, 6]]</span>

<span class="hljs-comment"># Aplicação prática: normalização</span>
dados = np.random.rand(<span class="hljs-number">100</span>, <span class="hljs-number">5</span>)
media = dados.mean(axis=<span class="hljs-number">0</span>)     <span class="hljs-comment"># shape (5,)</span>
std = dados.std(axis=<span class="hljs-number">0</span>)        <span class="hljs-comment"># shape (5,)</span>
normalizados = (dados - media) / std  <span class="hljs-comment"># Broadcasting</span>
</div></code></pre>
<h4 id="indexa%C3%A7%C3%A3o-e-fatiamento">Indexação e Fatiamento</h4>
<p><strong>1. Indexação Básica:</strong></p>
<pre class="hljs"><code><div>arr = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])

<span class="hljs-comment"># Acessar elemento</span>
primeiro = arr[<span class="hljs-number">0</span>]      <span class="hljs-comment"># 10</span>
ultimo = arr[<span class="hljs-number">-1</span>]       <span class="hljs-comment"># 50</span>

<span class="hljs-comment"># 2D</span>
arr2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])
elemento = arr2d[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]  <span class="hljs-comment"># 6 (linha 1, coluna 2)</span>
linha = arr2d[<span class="hljs-number">1</span>]        <span class="hljs-comment"># [4, 5, 6]</span>
coluna = arr2d[:, <span class="hljs-number">1</span>]    <span class="hljs-comment"># [2, 5, 8]</span>
</div></code></pre>
<p><strong>2. Slicing (Fatiamento):</strong></p>
<pre class="hljs"><code><div>arr = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])

<span class="hljs-comment"># [start:stop:step]</span>
fatia = arr[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>]       <span class="hljs-comment"># [2, 3, 4, 5, 6]</span>
cada_dois = arr[::<span class="hljs-number">2</span>]   <span class="hljs-comment"># [0, 2, 4, 6, 8]</span>
reverso = arr[::<span class="hljs-number">-1</span>]    <span class="hljs-comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span>

<span class="hljs-comment"># 2D</span>
arr2d = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
sub = arr2d[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">1</span>:<span class="hljs-number">3</span>]  <span class="hljs-comment"># Linhas 0-1, Colunas 1-2</span>
</div></code></pre>
<p><strong>3. Indexação Booleana:</strong></p>
<p><strong>Definição:</strong> Usar array booleano para selecionar elementos.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Filtrar dados por condição</li>
<li>Selecionar subset baseado em critérios</li>
<li>Máscara condicional</li>
</ul>
<pre class="hljs"><code><div>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>])

<span class="hljs-comment"># Criar máscara</span>
mascara = arr &gt; <span class="hljs-number">5</span>      <span class="hljs-comment"># [False, False, False, False, False, True, ...]</span>
maiores_5 = arr[mascara]  <span class="hljs-comment"># [6, 7, 8, 9, 10]</span>

<span class="hljs-comment"># Direto</span>
pares = arr[arr % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># [2, 4, 6, 8, 10]</span>

<span class="hljs-comment"># Múltiplas condições</span>
entre = arr[(arr &gt; <span class="hljs-number">3</span>) &amp; (arr &lt; <span class="hljs-number">8</span>)]  <span class="hljs-comment"># [4, 5, 6, 7]</span>

<span class="hljs-comment"># Modificar com máscara</span>
arr[arr &gt; <span class="hljs-number">5</span>] = <span class="hljs-number">99</span>  <span class="hljs-comment"># Substitui valores &gt; 5 por 99</span>
</div></code></pre>
<p><strong>4. Fancy Indexing:</strong></p>
<p><strong>Definição:</strong> Usar array de índices para selecionar elementos.</p>
<pre class="hljs"><code><div>arr = np.array([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>])

<span class="hljs-comment"># Array de índices</span>
indices = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]
selecionados = arr[indices]  <span class="hljs-comment"># [10, 30, 50]</span>

<span class="hljs-comment"># 2D</span>
arr2d = np.arange(<span class="hljs-number">12</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
linhas = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]
colunas = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]
elementos = arr2d[linhas, colunas]  <span class="hljs-comment"># [arr2d[0,1], arr2d[2,3]]</span>
</div></code></pre>
<h4 id="opera%C3%A7%C3%B5es-estat%C3%ADsticas">Operações Estatísticas</h4>
<p><strong>Funções básicas:</strong></p>
<pre class="hljs"><code><div>arr = np.random.randn(<span class="hljs-number">1000</span>)

<span class="hljs-comment"># Tendência central</span>
media = np.mean(arr)
mediana = np.median(arr)

<span class="hljs-comment"># Dispersão</span>
variancia = np.var(arr)
desvio_padrao = np.std(arr)

<span class="hljs-comment"># Extremos</span>
minimo = np.min(arr)
maximo = np.max(arr)
amplitude = np.ptp(arr)  <span class="hljs-comment"># Peak to peak</span>

<span class="hljs-comment"># Percentis</span>
q25 = np.percentile(arr, <span class="hljs-number">25</span>)
q50 = np.percentile(arr, <span class="hljs-number">50</span>)
q75 = np.percentile(arr, <span class="hljs-number">75</span>)

<span class="hljs-comment"># Agregação</span>
soma = np.sum(arr)
produto = np.prod(arr)
</div></code></pre>
<p><strong>Operações por eixo:</strong></p>
<p><strong>Conceito de eixo (axis):</strong></p>
<ul>
<li>axis=0: Ao longo das linhas (colunas resultantes)</li>
<li>axis=1: Ao longo das colunas (linhas resultantes)</li>
<li>axis=None: Todo o array</li>
</ul>
<pre class="hljs"><code><div>arr2d = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])

<span class="hljs-comment"># Soma</span>
soma_total = np.sum(arr2d)          <span class="hljs-comment"># 21</span>
soma_colunas = np.sum(arr2d, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [5, 7, 9]</span>
soma_linhas = np.sum(arr2d, axis=<span class="hljs-number">1</span>)   <span class="hljs-comment"># [6, 15]</span>

<span class="hljs-comment"># Média</span>
media_colunas = np.mean(arr2d, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [2.5, 3.5, 4.5]</span>
media_linhas = np.mean(arr2d, axis=<span class="hljs-number">1</span>)   <span class="hljs-comment"># [2, 5]</span>

<span class="hljs-comment"># Máximo e mínimo</span>
max_colunas = np.max(arr2d, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [4, 5, 6]</span>
min_linhas = np.min(arr2d, axis=<span class="hljs-number">1</span>)   <span class="hljs-comment"># [1, 4]</span>

<span class="hljs-comment"># Índices de máximo e mínimo</span>
idx_max = np.argmax(arr2d)           <span class="hljs-comment"># 5 (índice no array achatado)</span>
idx_max_colunas = np.argmax(arr2d, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [1, 1, 1]</span>
</div></code></pre>
<h4 id="%C3%A1lgebra-linear">Álgebra Linear</h4>
<p><strong>Multiplicação de vetores e matrizes:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Produto escalar (dot product)</span>
a = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
b = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])
dot = np.dot(a, b)  <span class="hljs-comment"># 1*4 + 2*5 + 3*6 = 32</span>

<span class="hljs-comment"># Produto de matrizes</span>
A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])
B = np.array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])
produto = np.dot(A, B)  <span class="hljs-comment"># ou A @ B (Python 3.5+)</span>
<span class="hljs-comment"># [[19, 22],</span>
<span class="hljs-comment">#  [43, 50]]</span>

<span class="hljs-comment"># Produto elemento a elemento (Hadamard)</span>
hadamard = A * B
<span class="hljs-comment"># [[5, 12],</span>
<span class="hljs-comment">#  [21, 32]]</span>
</div></code></pre>
<p><strong>Operações matriciais:</strong></p>
<pre class="hljs"><code><div>A = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])

<span class="hljs-comment"># Transposta</span>
A_T = A.T
<span class="hljs-comment"># [[1, 3],</span>
<span class="hljs-comment">#  [2, 4]]</span>

<span class="hljs-comment"># Determinante</span>
det = np.linalg.det(A)  <span class="hljs-comment"># -2.0</span>

<span class="hljs-comment"># Inversa</span>
inv = np.linalg.inv(A)
<span class="hljs-comment"># [[-2. ,  1. ],</span>
<span class="hljs-comment">#  [ 1.5, -0.5]]</span>

<span class="hljs-comment"># Verificar: A @ inv deve ser identidade</span>
identidade = A @ inv

<span class="hljs-comment"># Traço (soma diagonal)</span>
trace = np.trace(A)  <span class="hljs-comment"># 5</span>

<span class="hljs-comment"># Posto (rank)</span>
rank = np.linalg.matrix_rank(A)

<span class="hljs-comment"># Autovalores e autovetores</span>
autovalores, autovetores = np.linalg.eig(A)
</div></code></pre>
<p><strong>Resolver sistemas lineares:</strong></p>
<p><strong>Problema:</strong> Ax = b</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Sistema: 3x + y = 9</span>
<span class="hljs-comment">#         x + 2y = 8</span>

A = np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])
b = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">8</span>])

<span class="hljs-comment"># Solução</span>
x = np.linalg.solve(A, b)  <span class="hljs-comment"># [2, 3]</span>

<span class="hljs-comment"># Verificação</span>
verificacao = A @ x  <span class="hljs-comment"># Deve ser igual a b</span>
</div></code></pre>
<h3 id="32-pandas---manipula%C3%A7%C3%A3o-de-dados">3.2 Pandas - Manipulação de Dados</h3>
<p><strong>Definição:</strong> Biblioteca para manipulação e análise de dados estruturados, fornecendo estruturas DataFrame e Series.</p>
<p><strong>Por que Pandas é essencial:</strong></p>
<ol>
<li>
<p><strong>Facilidade de uso</strong></p>
<ul>
<li>API intuitiva</li>
<li>Integração com NumPy</li>
<li>Sintaxe expressiva</li>
</ul>
</li>
<li>
<p><strong>Funcionalidade rica</strong></p>
<ul>
<li>Leitura/escrita de múltiplos formatos</li>
<li>Limpeza e transformação</li>
<li>Agrupamento e agregação</li>
<li>Time series</li>
</ul>
</li>
<li>
<p><strong>Performance</strong></p>
<ul>
<li>Operações vetorizadas</li>
<li>Implementações otimizadas em Cython</li>
<li>Uso eficiente de memória</li>
</ul>
</li>
</ol>
<p><strong>Estruturas de dados principais:</strong></p>
<h4 id="series">Series</h4>
<p><strong>Definição:</strong> Array unidimensional rotulado, similar a uma coluna de planilha.</p>
<p><strong>Características:</strong></p>
<ul>
<li>1D labeled array</li>
<li>Pode conter qualquer tipo de dado</li>
<li>Tem índice (labels)</li>
<li>Similar a dicionário</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Representar uma única variável</li>
<li>Operações em uma dimensão</li>
<li>Time series simples</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

<span class="hljs-comment"># Criação</span>
s = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])

<span class="hljs-comment"># Com índice customizado</span>
s = pd.Series([<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>], index=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])

<span class="hljs-comment"># De dicionário</span>
s = pd.Series({<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>})

<span class="hljs-comment"># Acesso</span>
print(s[<span class="hljs-number">0</span>])      <span class="hljs-comment"># Por posição</span>
print(s[<span class="hljs-string">'a'</span>])    <span class="hljs-comment"># Por label</span>
print(s.iloc[<span class="hljs-number">0</span>]) <span class="hljs-comment"># Explicitamente por posição</span>
print(s.loc[<span class="hljs-string">'a'</span>]) <span class="hljs-comment"># Explicitamente por label</span>

<span class="hljs-comment"># Atributos</span>
print(s.index)   <span class="hljs-comment"># Index(['a', 'b', 'c'])</span>
print(s.values)  <span class="hljs-comment"># array([1, 2, 3])</span>
print(s.dtype)   <span class="hljs-comment"># dtype('int64')</span>

<span class="hljs-comment"># Operações</span>
print(s + <span class="hljs-number">10</span>)    <span class="hljs-comment"># Adiciona 10 a todos</span>
print(s * <span class="hljs-number">2</span>)     <span class="hljs-comment"># Multiplica todos por 2</span>
print(s[s &gt; <span class="hljs-number">1</span>])  <span class="hljs-comment"># Filtra valores &gt; 1</span>
</div></code></pre>
<h4 id="dataframe">DataFrame</h4>
<p><strong>Definição:</strong> Estrutura bidimensional rotulada com colunas potencialmente de diferentes tipos.</p>
<p><strong>Características:</strong></p>
<ul>
<li>Tabela 2D</li>
<li>Colunas podem ter tipos diferentes</li>
<li>Índice para linhas e colunas</li>
<li>Similar a planilha ou tabela SQL</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados tabulares</li>
<li>Múltiplas variáveis</li>
<li>Análise de dados estruturados</li>
</ul>
<p><strong>Como criar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># De dicionário</span>
df = pd.DataFrame({
    <span class="hljs-string">'nome'</span>: [<span class="hljs-string">'Ana'</span>, <span class="hljs-string">'Bruno'</span>, <span class="hljs-string">'Carlos'</span>],
    <span class="hljs-string">'idade'</span>: [<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>],
    <span class="hljs-string">'cidade'</span>: [<span class="hljs-string">'SP'</span>, <span class="hljs-string">'RJ'</span>, <span class="hljs-string">'BH'</span>]
})

<span class="hljs-comment"># De listas</span>
dados = [
    [<span class="hljs-string">'Ana'</span>, <span class="hljs-number">25</span>, <span class="hljs-string">'SP'</span>],
    [<span class="hljs-string">'Bruno'</span>, <span class="hljs-number">30</span>, <span class="hljs-string">'RJ'</span>],
    [<span class="hljs-string">'Carlos'</span>, <span class="hljs-number">35</span>, <span class="hljs-string">'BH'</span>]
]
df = pd.DataFrame(dados, columns=[<span class="hljs-string">'nome'</span>, <span class="hljs-string">'idade'</span>, <span class="hljs-string">'cidade'</span>])

<span class="hljs-comment"># De array NumPy</span>
arr = np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
df = pd.DataFrame(arr, columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>])

<span class="hljs-comment"># Ler de arquivo</span>
df = pd.read_csv(<span class="hljs-string">'dados.csv'</span>)
df = pd.read_excel(<span class="hljs-string">'dados.xlsx'</span>)
df = pd.read_json(<span class="hljs-string">'dados.json'</span>)
</div></code></pre>
<p><strong>Inspeção de dados:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Visualização</span>
df.head()        <span class="hljs-comment"># Primeiras 5 linhas</span>
df.head(<span class="hljs-number">10</span>)      <span class="hljs-comment"># Primeiras 10 linhas</span>
df.tail()        <span class="hljs-comment"># Últimas 5 linhas</span>
df.sample(<span class="hljs-number">5</span>)     <span class="hljs-comment"># 5 linhas aleatórias</span>

<span class="hljs-comment"># Informações</span>
df.info()        <span class="hljs-comment"># Resumo geral</span>
df.describe()    <span class="hljs-comment"># Estatísticas descritivas</span>
df.shape         <span class="hljs-comment"># (linhas, colunas)</span>
df.columns       <span class="hljs-comment"># Nomes das colunas</span>
df.dtypes        <span class="hljs-comment"># Tipos de dados</span>
df.index         <span class="hljs-comment"># Índice</span>

<span class="hljs-comment"># Valores</span>
df.values        <span class="hljs-comment"># Array NumPy dos valores</span>
df.to_numpy()    <span class="hljs-comment"># Mesmo que values</span>
</div></code></pre>
<p><strong>Seleção de dados:</strong></p>
<p><strong>1. Seleção de colunas:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Uma coluna (retorna Series)</span>
idade = df[<span class="hljs-string">'idade'</span>]
idade = df.idade  <span class="hljs-comment"># Notação de atributo (evite se nome tem espaços)</span>

<span class="hljs-comment"># Múltiplas colunas (retorna DataFrame)</span>
subset = df[[<span class="hljs-string">'nome'</span>, <span class="hljs-string">'idade'</span>]]

<span class="hljs-comment"># Todas exceto algumas</span>
sem_idade = df.drop(<span class="hljs-string">'idade'</span>, axis=<span class="hljs-number">1</span>)
sem_varias = df.drop([<span class="hljs-string">'idade'</span>, <span class="hljs-string">'cidade'</span>], axis=<span class="hljs-number">1</span>)
</div></code></pre>
<p><strong>2. Seleção de linhas:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Por índice numérico</span>
primeiras = df.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]      <span class="hljs-comment"># Linhas 0, 1, 2</span>
linha = df.iloc[<span class="hljs-number">0</span>]            <span class="hljs-comment"># Primeira linha</span>
ultimas = df.iloc[<span class="hljs-number">-3</span>:]        <span class="hljs-comment"># Últimas 3 linhas</span>

<span class="hljs-comment"># Por label</span>
linha = df.loc[<span class="hljs-number">0</span>]             <span class="hljs-comment"># Linha com índice 0</span>
intervalo = df.loc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]       <span class="hljs-comment"># Índices 0, 1, 2 (inclusivo)</span>

<span class="hljs-comment"># Por condição</span>
maiores_30 = df[df[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">30</span>]
sp = df[df[<span class="hljs-string">'cidade'</span>] == <span class="hljs-string">'SP'</span>]

<span class="hljs-comment"># Múltiplas condições</span>
criterio = df[(df[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">25</span>) &amp; (df[<span class="hljs-string">'cidade'</span>] == <span class="hljs-string">'SP'</span>)]
ou = df[(df[<span class="hljs-string">'idade'</span>] &lt; <span class="hljs-number">20</span>) | (df[<span class="hljs-string">'cidade'</span>] == <span class="hljs-string">'RJ'</span>)]
</div></code></pre>
<p><strong>3. Seleção combinada:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># loc[linhas, colunas]</span>
valor = df.loc[<span class="hljs-number">0</span>, <span class="hljs-string">'nome'</span>]              <span class="hljs-comment"># Valor específico</span>
subset = df.loc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, [<span class="hljs-string">'nome'</span>, <span class="hljs-string">'idade'</span>]] <span class="hljs-comment"># Subset</span>

<span class="hljs-comment"># iloc[linhas, colunas]</span>
valor = df.iloc[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]                  <span class="hljs-comment"># Primeira linha, primeira coluna</span>
subset = df.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">2</span>]             <span class="hljs-comment"># Subset por posição</span>

<span class="hljs-comment"># Condicional + colunas</span>
subset = df.loc[df[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">25</span>, [<span class="hljs-string">'nome'</span>, <span class="hljs-string">'cidade'</span>]]
</div></code></pre>
<p><strong>Manipulação de dados:</strong></p>
<p><strong>1. Adicionar colunas:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Nova coluna constante</span>
df[<span class="hljs-string">'pais'</span>] = <span class="hljs-string">'Brasil'</span>

<span class="hljs-comment"># Calculada de outras colunas</span>
df[<span class="hljs-string">'idade_meses'</span>] = df[<span class="hljs-string">'idade'</span>] * <span class="hljs-number">12</span>

<span class="hljs-comment"># Condicional</span>
df[<span class="hljs-string">'faixa'</span>] = df[<span class="hljs-string">'idade'</span>].apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'Jovem'</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">30</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'Adulto'</span>)

<span class="hljs-comment"># Múltiplas condições</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificar</span><span class="hljs-params">(idade)</span>:</span>
    <span class="hljs-keyword">if</span> idade &lt; <span class="hljs-number">20</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Jovem'</span>
    <span class="hljs-keyword">elif</span> idade &lt; <span class="hljs-number">40</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Adulto'</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Senior'</span>

df[<span class="hljs-string">'categoria'</span>] = df[<span class="hljs-string">'idade'</span>].apply(classificar)
</div></code></pre>
<p><strong>2. Modificar colunas:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Sobrescrever</span>
df[<span class="hljs-string">'idade'</span>] = df[<span class="hljs-string">'idade'</span>] + <span class="hljs-number">1</span>

<span class="hljs-comment"># Modificar com condição</span>
df.loc[df[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">30</span>, <span class="hljs-string">'idade'</span>] = <span class="hljs-number">30</span>

<span class="hljs-comment"># Renomear</span>
df = df.rename(columns={<span class="hljs-string">'idade'</span>: <span class="hljs-string">'Idade'</span>, <span class="hljs-string">'nome'</span>: <span class="hljs-string">'Nome'</span>})

<span class="hljs-comment"># Mudar tipo</span>
df[<span class="hljs-string">'idade'</span>] = df[<span class="hljs-string">'idade'</span>].astype(float)
df[<span class="hljs-string">'nome'</span>] = df[<span class="hljs-string">'nome'</span>].astype(str)
</div></code></pre>
<p><strong>3. Remover:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Colunas</span>
df = df.drop(<span class="hljs-string">'idade'</span>, axis=<span class="hljs-number">1</span>)
df = df.drop([<span class="hljs-string">'idade'</span>, <span class="hljs-string">'cidade'</span>], axis=<span class="hljs-number">1</span>)

<span class="hljs-comment"># Linhas</span>
df = df.drop(<span class="hljs-number">0</span>)                  <span class="hljs-comment"># Por índice</span>
df = df.drop([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])          <span class="hljs-comment"># Múltiplas</span>
df = df[df[<span class="hljs-string">'idade'</span>] &gt; <span class="hljs-number">25</span>]        <span class="hljs-comment"># Por condição</span>
</div></code></pre>
<p><strong>Tratamento de valores ausentes:</strong></p>
<p><strong>Identificar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Verificar nulos</span>
df.isnull()           <span class="hljs-comment"># DataFrame booleano</span>
df.isna()             <span class="hljs-comment"># Alias de isnull</span>
df.isnull().sum()     <span class="hljs-comment"># Contar por coluna</span>
df.isnull().sum().sum()  <span class="hljs-comment"># Total de nulos</span>

<span class="hljs-comment"># Verificar não-nulos</span>
df.notnull()
df.notna()

<span class="hljs-comment"># Linhas com algum nulo</span>
df[df.isnull().any(axis=<span class="hljs-number">1</span>)]

<span class="hljs-comment"># Linhas sem nulos</span>
df[df.notnull().all(axis=<span class="hljs-number">1</span>)]
</div></code></pre>
<p><strong>Remover:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Remover linhas com qualquer nulo</span>
df_sem_nulos = df.dropna()

<span class="hljs-comment"># Remover linhas onde todas as colunas são nulas</span>
df = df.dropna(how=<span class="hljs-string">'all'</span>)

<span class="hljs-comment"># Remover apenas se colunas específicas têm nulos</span>
df = df.dropna(subset=[<span class="hljs-string">'idade'</span>, <span class="hljs-string">'nome'</span>])

<span class="hljs-comment"># Remover colunas com nulos</span>
df = df.dropna(axis=<span class="hljs-number">1</span>)

<span class="hljs-comment"># Threshold: manter linhas com pelo menos N não-nulos</span>
df = df.dropna(thresh=<span class="hljs-number">2</span>)
</div></code></pre>
<p><strong>Preencher:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Com valor constante</span>
df[<span class="hljs-string">'idade'</span>] = df[<span class="hljs-string">'idade'</span>].fillna(<span class="hljs-number">0</span>)
df = df.fillna(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Todas as colunas</span>

<span class="hljs-comment"># Com estatística</span>
df[<span class="hljs-string">'idade'</span>] = df[<span class="hljs-string">'idade'</span>].fillna(df[<span class="hljs-string">'idade'</span>].mean())
df[<span class="hljs-string">'idade'</span>] = df[<span class="hljs-string">'idade'</span>].fillna(df[<span class="hljs-string">'idade'</span>].median())
df[<span class="hljs-string">'categoria'</span>] = df[<span class="hljs-string">'categoria'</span>].fillna(df[<span class="hljs-string">'categoria'</span>].mode()[<span class="hljs-number">0</span>])

<span class="hljs-comment"># Forward fill (propagar último valor válido)</span>
df = df.fillna(method=<span class="hljs-string">'ffill'</span>)

<span class="hljs-comment"># Backward fill (usar próximo valor válido)</span>
df = df.fillna(method=<span class="hljs-string">'bfill'</span>)

<span class="hljs-comment"># Interpolação</span>
df[<span class="hljs-string">'valor'</span>] = df[<span class="hljs-string">'valor'</span>].interpolate()
df[<span class="hljs-string">'valor'</span>] = df[<span class="hljs-string">'valor'</span>].interpolate(method=<span class="hljs-string">'linear'</span>)
</div></code></pre>
<p><strong>Agrupamento e Agregação:</strong></p>
<p><strong>GroupBy:</strong></p>
<p><strong>Definição:</strong> Dividir dados em grupos baseado em critério, aplicar função a cada grupo e combinar resultados.</p>
<p><strong>Processo (Split-Apply-Combine):</strong></p>
<ol>
<li><strong>Split:</strong> Dividir DataFrame em grupos</li>
<li><strong>Apply:</strong> Aplicar função a cada grupo</li>
<li><strong>Combine:</strong> Combinar resultados</li>
</ol>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Análises por categoria</li>
<li>Estatísticas por grupo</li>
<li>Agregações complexas</li>
<li>Pivot tables</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Agrupar por uma coluna</span>
por_cidade = df.groupby(<span class="hljs-string">'cidade'</span>)

<span class="hljs-comment"># Ver grupos</span>
print(por_cidade.groups)

<span class="hljs-comment"># Estatística simples</span>
media_idade = por_cidade[<span class="hljs-string">'idade'</span>].mean()
max_idade = por_cidade[<span class="hljs-string">'idade'</span>].max()
contagem = por_cidade.size()

<span class="hljs-comment"># Múltiplas agregações</span>
estatisticas = por_cidade[<span class="hljs-string">'idade'</span>].agg([<span class="hljs-string">'mean'</span>, <span class="hljs-string">'min'</span>, <span class="hljs-string">'max'</span>, <span class="hljs-string">'std'</span>])

<span class="hljs-comment"># Diferentes agregações por coluna</span>
resultado = por_cidade.agg({
    <span class="hljs-string">'idade'</span>: [<span class="hljs-string">'mean'</span>, <span class="hljs-string">'min'</span>, <span class="hljs-string">'max'</span>],
    <span class="hljs-string">'salario'</span>: [<span class="hljs-string">'sum'</span>, <span class="hljs-string">'mean'</span>]
})

<span class="hljs-comment"># Múltiplas colunas de agrupamento</span>
por_cidade_genero = df.groupby([<span class="hljs-string">'cidade'</span>, <span class="hljs-string">'genero'</span>])
media = por_cidade_genero[<span class="hljs-string">'salario'</span>].mean()

<span class="hljs-comment"># Função customizada</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">amplitude</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">return</span> x.max() - x.min()

amplitudes = por_cidade[<span class="hljs-string">'idade'</span>].agg(amplitude)

<span class="hljs-comment"># Transformação (mantém shape original)</span>
normalized = por_cidade[<span class="hljs-string">'idade'</span>].transform(<span class="hljs-keyword">lambda</span> x: (x - x.mean()) / x.std())
</div></code></pre>
<p><strong>Pivot Tables:</strong></p>
<p><strong>Definição:</strong> Tabela de resumo que agrupa dados e aplica função de agregação.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Criar tabelas de resumo</li>
<li>Análise multidimensional</li>
<li>Relatórios executivos</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Pivot table básica</span>
pivot = pd.pivot_table(
    df,
    values=<span class="hljs-string">'salario'</span>,      <span class="hljs-comment"># Coluna a agregar</span>
    index=<span class="hljs-string">'cidade'</span>,         <span class="hljs-comment"># Linhas</span>
    columns=<span class="hljs-string">'genero'</span>,       <span class="hljs-comment"># Colunas</span>
    aggfunc=<span class="hljs-string">'mean'</span>          <span class="hljs-comment"># Função de agregação</span>
)

<span class="hljs-comment"># Múltiplas agregações</span>
pivot = pd.pivot_table(
    df,
    values=<span class="hljs-string">'salario'</span>,
    index=<span class="hljs-string">'cidade'</span>,
    columns=<span class="hljs-string">'genero'</span>,
    aggfunc=[<span class="hljs-string">'mean'</span>, <span class="hljs-string">'sum'</span>, <span class="hljs-string">'count'</span>]
)

<span class="hljs-comment"># Múltiplos índices e colunas</span>
pivot = pd.pivot_table(
    df,
    values=<span class="hljs-string">'salario'</span>,
    index=[<span class="hljs-string">'cidade'</span>, <span class="hljs-string">'departamento'</span>],
    columns=[<span class="hljs-string">'genero'</span>, <span class="hljs-string">'faixa_etaria'</span>],
    aggfunc=<span class="hljs-string">'mean'</span>,
    fill_value=<span class="hljs-number">0</span>,           <span class="hljs-comment"># Preencher nulos</span>
    margins=<span class="hljs-literal">True</span>            <span class="hljs-comment"># Adicionar totais</span>
)
</div></code></pre>
<p><strong>Merge e Join:</strong></p>
<p><strong>Definição:</strong> Combinar DataFrames baseado em colunas ou índices comuns.</p>
<p><strong>Tipos de join:</strong></p>
<ul>
<li><strong>Inner:</strong> Apenas matches (interseção)</li>
<li><strong>Left:</strong> Todos da esquerda + matches</li>
<li><strong>Right:</strong> Todos da direita + matches</li>
<li><strong>Outer:</strong> Todos de ambos (união)</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Combinar dados de diferentes fontes</li>
<li>Enriquecer dataset</li>
<li>Relacionamentos tipo SQL</li>
</ul>
<pre class="hljs"><code><div>df1 = pd.DataFrame({
    <span class="hljs-string">'id'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],
    <span class="hljs-string">'nome'</span>: [<span class="hljs-string">'Ana'</span>, <span class="hljs-string">'Bruno'</span>, <span class="hljs-string">'Carlos'</span>]
})

df2 = pd.DataFrame({
    <span class="hljs-string">'id'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>],
    <span class="hljs-string">'salario'</span>: [<span class="hljs-number">3000</span>, <span class="hljs-number">4000</span>, <span class="hljs-number">5000</span>]
})

<span class="hljs-comment"># Inner join (padrão)</span>
inner = pd.merge(df1, df2, on=<span class="hljs-string">'id'</span>)
<span class="hljs-comment"># Resultado: id 1 e 2 (interseção)</span>

<span class="hljs-comment"># Left join</span>
left = pd.merge(df1, df2, on=<span class="hljs-string">'id'</span>, how=<span class="hljs-string">'left'</span>)
<span class="hljs-comment"># Resultado: todos de df1, salario NaN para id 3</span>

<span class="hljs-comment"># Right join</span>
right = pd.merge(df1, df2, on=<span class="hljs-string">'id'</span>, how=<span class="hljs-string">'right'</span>)
<span class="hljs-comment"># Resultado: todos de df2, nome NaN para id 4</span>

<span class="hljs-comment"># Outer join</span>
outer = pd.merge(df1, df2, on=<span class="hljs-string">'id'</span>, how=<span class="hljs-string">'outer'</span>)
<span class="hljs-comment"># Resultado: todos os ids (1, 2, 3, 4)</span>

<span class="hljs-comment"># Diferentes nomes de coluna</span>
df3 = pd.DataFrame({
    <span class="hljs-string">'pessoa_id'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>],
    <span class="hljs-string">'departamento'</span>: [<span class="hljs-string">'TI'</span>, <span class="hljs-string">'RH'</span>, <span class="hljs-string">'Vendas'</span>]
})

merged = pd.merge(df1, df3, left_on=<span class="hljs-string">'id'</span>, right_on=<span class="hljs-string">'pessoa_id'</span>)

<span class="hljs-comment"># Múltiplas colunas</span>
merged = pd.merge(df1, df2, on=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'nome'</span>])

<span class="hljs-comment"># Sufixos para colunas duplicadas</span>
merged = pd.merge(df1, df2, on=<span class="hljs-string">'id'</span>, suffixes=(<span class="hljs-string">'_esq'</span>, <span class="hljs-string">'_dir'</span>))
</div></code></pre>
<p><strong>Concatenação:</strong></p>
<p><strong>Definição:</strong> Empilhar DataFrames ao longo de um eixo.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Combinar datasets similares</li>
<li>Adicionar mais observações</li>
<li>Adicionar mais variáveis</li>
</ul>
<pre class="hljs"><code><div>df1 = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-string">'B'</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]})
df2 = pd.DataFrame({<span class="hljs-string">'A'</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>], <span class="hljs-string">'B'</span>: [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]})

<span class="hljs-comment"># Concatenar verticalmente (empilhar linhas)</span>
vertical = pd.concat([df1, df2])
vertical = pd.concat([df1, df2], ignore_index=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># Resetar índice</span>

<span class="hljs-comment"># Concatenar horizontalmente (adicionar colunas)</span>
horizontal = pd.concat([df1, df2], axis=<span class="hljs-number">1</span>)

<span class="hljs-comment"># Lidar com colunas diferentes</span>
df3 = pd.DataFrame({<span class="hljs-string">'C'</span>: [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>], <span class="hljs-string">'D'</span>: [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>]})
combined = pd.concat([df1, df3], axis=<span class="hljs-number">1</span>)  <span class="hljs-comment"># NaN nas não existentes</span>
</div></code></pre>
<hr>
<h2 id="4-manipula%C3%A7%C3%A3o-de-dados">4. Manipulação de Dados</h2>
<h3 id="41-leitura-e-escrita-de-arquivos">4.1 Leitura e Escrita de Arquivos</h3>
<p><strong>CSV (Comma-Separated Values):</strong></p>
<p><strong>Definição:</strong> Formato texto onde valores são separados por delimitador (geralmente vírgula).</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados tabulares simples</li>
<li>Compatibilidade universal</li>
<li>Dados pequenos a médios (&lt;100MB)</li>
<li>Interoperabilidade entre sistemas</li>
</ul>
<p><strong>Vantagens:</strong></p>
<ul>
<li>Legível por humanos</li>
<li>Amplamente suportado</li>
<li>Simples de editar</li>
</ul>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Sem tipos de dados (tudo é texto)</li>
<li>Pode ser grande</li>
<li>Lento para grandes volumes</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Ler CSV</span>
df = pd.read_csv(<span class="hljs-string">'dados.csv'</span>)

<span class="hljs-comment"># Com opções</span>
df = pd.read_csv(
    <span class="hljs-string">'dados.csv'</span>,
    sep=<span class="hljs-string">';'</span>,              <span class="hljs-comment"># Delimitador diferente</span>
    encoding=<span class="hljs-string">'utf-8'</span>,     <span class="hljs-comment"># Encoding</span>
    thousands=<span class="hljs-string">','</span>,        <span class="hljs-comment"># Separador de milhares</span>
    decimal=<span class="hljs-string">'.'</span>,          <span class="hljs-comment"># Separador decimal</span>
    parse_dates=[<span class="hljs-string">'data'</span>], <span class="hljs-comment"># Parsear como data</span>
    index_col=<span class="hljs-string">'id'</span>,       <span class="hljs-comment"># Usar coluna como índice</span>
    usecols=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>],   <span class="hljs-comment"># Ler apenas colunas específicas</span>
    nrows=<span class="hljs-number">1000</span>,           <span class="hljs-comment"># Ler apenas N linhas</span>
    skiprows=<span class="hljs-number">2</span>,           <span class="hljs-comment"># Pular primeiras N linhas</span>
    na_values=[<span class="hljs-string">'NA'</span>, <span class="hljs-string">'?'</span>] <span class="hljs-comment"># Valores a considerar como nulos</span>
)

<span class="hljs-comment"># Escrever CSV</span>
df.to_csv(<span class="hljs-string">'saida.csv'</span>, index=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># Com opções</span>
df.to_csv(
    <span class="hljs-string">'saida.csv'</span>,
    index=<span class="hljs-literal">False</span>,
    sep=<span class="hljs-string">';'</span>,
    encoding=<span class="hljs-string">'utf-8'</span>,
    columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>],   <span class="hljs-comment"># Apenas colunas específicas</span>
    float_format=<span class="hljs-string">'%.2f'</span>,  <span class="hljs-comment"># Formato de floats</span>
    na_rep=<span class="hljs-string">'NULL'</span>         <span class="hljs-comment"># Representação de nulos</span>
)
</div></code></pre>
<p><strong>Excel:</strong></p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Interoperar com usuários Excel</li>
<li>Múltiplas planilhas</li>
<li>Formatação importante</li>
</ul>
<p><strong>Vantagens:</strong></p>
<ul>
<li>Amplamente usado em negócios</li>
<li>Suporta múltiplas sheets</li>
<li>Formatação rica</li>
</ul>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Maior que CSV</li>
<li>Mais lento</li>
<li>Tamanho limitado</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Ler Excel</span>
df = pd.read_excel(<span class="hljs-string">'dados.xlsx'</span>)

<span class="hljs-comment"># Com opções</span>
df = pd.read_excel(
    <span class="hljs-string">'dados.xlsx'</span>,
    sheet_name=<span class="hljs-string">'Planilha1'</span>,  <span class="hljs-comment"># ou 0 para primeira</span>
    header=<span class="hljs-number">0</span>,                 <span class="hljs-comment"># Linha do cabeçalho</span>
    usecols=<span class="hljs-string">'A:C'</span>,            <span class="hljs-comment"># Colunas a ler</span>
    nrows=<span class="hljs-number">100</span>
)

<span class="hljs-comment"># Ler múltiplas planilhas</span>
dfs = pd.read_excel(<span class="hljs-string">'dados.xlsx'</span>, sheet_name=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># Dicionário</span>
df1 = dfs[<span class="hljs-string">'Planilha1'</span>]
df2 = dfs[<span class="hljs-string">'Planilha2'</span>]

<span class="hljs-comment"># Escrever Excel</span>
df.to_excel(<span class="hljs-string">'saida.xlsx'</span>, index=<span class="hljs-literal">False</span>)

<span class="hljs-comment"># Múltiplas planilhas</span>
<span class="hljs-keyword">with</span> pd.ExcelWriter(<span class="hljs-string">'saida.xlsx'</span>) <span class="hljs-keyword">as</span> writer:
    df1.to_excel(writer, sheet_name=<span class="hljs-string">'Sheet1'</span>, index=<span class="hljs-literal">False</span>)
    df2.to_excel(writer, sheet_name=<span class="hljs-string">'Sheet2'</span>, index=<span class="hljs-literal">False</span>)
</div></code></pre>
<p><strong>JSON:</strong></p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>APIs web</li>
<li>Dados hierárquicos/nested</li>
<li>Dados semi-estruturados</li>
</ul>
<p><strong>Vantagens:</strong></p>
<ul>
<li>Legível por humanos</li>
<li>Estrutura flexível</li>
<li>Padrão web</li>
</ul>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Verboso</li>
<li>Maior que formatos binários</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Ler JSON</span>
df = pd.read_json(<span class="hljs-string">'dados.json'</span>)

<span class="hljs-comment"># Com orientação específica</span>
df = pd.read_json(<span class="hljs-string">'dados.json'</span>, orient=<span class="hljs-string">'records'</span>)
<span class="hljs-comment"># orient: 'split', 'records', 'index', 'columns', 'values'</span>

<span class="hljs-comment"># Escrever JSON</span>
df.to_json(<span class="hljs-string">'saida.json'</span>, orient=<span class="hljs-string">'records'</span>, indent=<span class="hljs-number">2</span>)
</div></code></pre>
<p><strong>Parquet:</strong></p>
<p><strong>Definição:</strong> Formato colunar binário eficiente.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Big data</li>
<li>Analytics</li>
<li>Armazenamento eficiente</li>
<li>Performance crítica</li>
</ul>
<p><strong>Vantagens:</strong></p>
<ul>
<li>Muito compacto</li>
<li>Leitura rápida</li>
<li>Preserva tipos</li>
<li>Compressão eficiente</li>
</ul>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Não legível por humanos</li>
<li>Menos universal que CSV</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Escrever Parquet</span>
df.to_parquet(<span class="hljs-string">'dados.parquet'</span>)

<span class="hljs-comment"># Com compressão</span>
df.to_parquet(<span class="hljs-string">'dados.parquet'</span>, compression=<span class="hljs-string">'gzip'</span>)
<span class="hljs-comment"># Opções: 'snappy', 'gzip', 'brotli'</span>

<span class="hljs-comment"># Ler Parquet</span>
df = pd.read_parquet(<span class="hljs-string">'dados.parquet'</span>)

<span class="hljs-comment"># Colunas específicas</span>
df = pd.read_parquet(<span class="hljs-string">'dados.parquet'</span>, columns=[<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>])
</div></code></pre>
<p><strong>SQL:</strong></p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados em banco de dados</li>
<li>Queries complexas</li>
<li>Grandes volumes</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine

<span class="hljs-comment"># Conectar</span>
engine = create_engine(<span class="hljs-string">'sqlite:///banco.db'</span>)

<span class="hljs-comment"># Ler de query</span>
df = pd.read_sql_query(<span class="hljs-string">'SELECT * FROM tabela WHERE idade &gt; 25'</span>, engine)

<span class="hljs-comment"># Ler tabela inteira</span>
df = pd.read_sql_table(<span class="hljs-string">'tabela'</span>, engine)

<span class="hljs-comment"># Escrever</span>
df.to_sql(<span class="hljs-string">'nova_tabela'</span>, engine, if_exists=<span class="hljs-string">'replace'</span>, index=<span class="hljs-literal">False</span>)
<span class="hljs-comment"># if_exists: 'fail', 'replace', 'append'</span>
</div></code></pre>
<h3 id="42-transforma%C3%A7%C3%B5es-avan%C3%A7adas">4.2 Transformações Avançadas</h3>
<p><strong>Apply:</strong></p>
<p><strong>Definição:</strong> Aplicar função ao longo de um eixo do DataFrame.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Transformações complexas</li>
<li>Operações linha por linha</li>
<li>Lógica customizada</li>
</ul>
<p><strong>Como usar:</strong></p>
<pre class="hljs"><code><div><span class="hljs-comment"># Apply em Series</span>
df[<span class="hljs-string">'idade_dobro'</span>] = df[<span class="hljs-string">'idade'</span>].apply(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>)

<span class="hljs-comment"># Função customizada</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classificar_idade</span><span class="hljs-params">(idade)</span>:</span>
    <span class="hljs-keyword">if</span> idade &lt; <span class="hljs-number">20</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Jovem'</span>
    <span class="hljs-keyword">elif</span> idade &lt; <span class="hljs-number">40</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Adulto'</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Senior'</span>

df[<span class="hljs-string">'faixa'</span>] = df[<span class="hljs-string">'idade'</span>].apply(classificar_idade)

<span class="hljs-comment"># Apply em DataFrame (por linha)</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calcular_imc</span><span class="hljs-params">(row)</span>:</span>
    <span class="hljs-keyword">return</span> row[<span class="hljs-string">'peso'</span>] / (row[<span class="hljs-string">'altura'</span>] ** <span class="hljs-number">2</span>)

df[<span class="hljs-string">'imc'</span>] = df.apply(calcular_imc, axis=<span class="hljs-number">1</span>)

<span class="hljs-comment"># Retornar múltiplos valores</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stats</span><span class="hljs-params">(row)</span>:</span>
    <span class="hljs-keyword">return</span> pd.Series({
        <span class="hljs-string">'soma'</span>: row[<span class="hljs-string">'A'</span>] + row[<span class="hljs-string">'B'</span>],
        <span class="hljs-string">'produto'</span>: row[<span class="hljs-string">'A'</span>] * row[<span class="hljs-string">'B'</span>]
    })

df[[<span class="hljs-string">'soma'</span>, <span class="hljs-string">'produto'</span>]] = df.apply(stats, axis=<span class="hljs-number">1</span>)

<span class="hljs-comment"># Apply por coluna</span>
totais = df.apply(sum, axis=<span class="hljs-number">0</span>)  <span class="hljs-comment"># Soma de cada coluna</span>
</div></code></pre>
<p><strong>Map:</strong></p>
<p><strong>Definição:</strong> Mapear valores usando dicionário ou função (apenas Series).</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Substituir valores</li>
<li>Codificar categorias</li>
<li>Transformações simples 1:1</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Com dicionário</span>
mapeamento = {<span class="hljs-string">'M'</span>: <span class="hljs-string">'Masculino'</span>, <span class="hljs-string">'F'</span>: <span class="hljs-string">'Feminino'</span>}
df[<span class="hljs-string">'genero_completo'</span>] = df[<span class="hljs-string">'genero'</span>].map(mapeamento)

<span class="hljs-comment"># Com função</span>
df[<span class="hljs-string">'idade_string'</span>] = df[<span class="hljs-string">'idade'</span>].map(str)

<span class="hljs-comment"># Map com lambda</span>
df[<span class="hljs-string">'idade_cat'</span>] = df[<span class="hljs-string">'idade'</span>].map(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">'Maior'</span> <span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">18</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'Menor'</span>)
</div></code></pre>
<p><strong>Apply vs Map:</strong></p>
<ul>
<li><strong>Apply:</strong> Mais versátil, DataFrame ou Series</li>
<li><strong>Map:</strong> Apenas Series, mais rápido para mapeamentos simples</li>
</ul>
<p><strong>Pivot e Melt:</strong></p>
<p><strong>Pivot (Wide format):</strong></p>
<p><strong>Definição:</strong> Transformar valores de uma coluna em novas colunas.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados em formato longo → largo</li>
<li>Criar tabelas de resumo</li>
<li>Facilitar visualização</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Dados originais (long format)</span>
vendas = pd.DataFrame({
    <span class="hljs-string">'data'</span>: [<span class="hljs-string">'2024-01-01'</span>, <span class="hljs-string">'2024-01-01'</span>, <span class="hljs-string">'2024-01-02'</span>, <span class="hljs-string">'2024-01-02'</span>],
    <span class="hljs-string">'produto'</span>: [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>],
    <span class="hljs-string">'vendas'</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">150</span>, <span class="hljs-number">120</span>, <span class="hljs-number">180</span>]
})

<span class="hljs-comment"># Pivot para wide format</span>
pivot = vendas.pivot(
    index=<span class="hljs-string">'data'</span>,
    columns=<span class="hljs-string">'produto'</span>,
    values=<span class="hljs-string">'vendas'</span>
)

<span class="hljs-comment"># Resultado:</span>
<span class="hljs-comment"># produto       A    B</span>
<span class="hljs-comment"># data</span>
<span class="hljs-comment"># 2024-01-01  100  150</span>
<span class="hljs-comment"># 2024-01-02  120  180</span>
</div></code></pre>
<p><strong>Melt (Long format):</strong></p>
<p><strong>Definição:</strong> Transformar colunas em linhas.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Dados largos → longos</li>
<li>Preparar para análise</li>
<li>Formato tidy</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Reverter pivot</span>
melted = pivot.reset_index().melt(
    id_vars=<span class="hljs-string">'data'</span>,
    var_name=<span class="hljs-string">'produto'</span>,
    value_name=<span class="hljs-string">'vendas'</span>
)

<span class="hljs-comment"># De volta ao formato original</span>
</div></code></pre>
<p><strong>String Operations:</strong></p>
<p><strong>Definição:</strong> Operações especializadas para colunas de texto.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Limpar dados textuais</li>
<li>Extrair informações</li>
<li>Padronizar formatos</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Acessor .str</span>
df[<span class="hljs-string">'nome_upper'</span>] = df[<span class="hljs-string">'nome'</span>].str.upper()
df[<span class="hljs-string">'nome_lower'</span>] = df[<span class="hljs-string">'nome'</span>].str.lower()
df[<span class="hljs-string">'nome_title'</span>] = df[<span class="hljs-string">'nome'</span>].str.title()

<span class="hljs-comment"># Remover espaços</span>
df[<span class="hljs-string">'nome_limpo'</span>] = df[<span class="hljs-string">'nome'</span>].str.strip()
df[<span class="hljs-string">'sem_espacos'</span>] = df[<span class="hljs-string">'nome'</span>].str.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">''</span>)

<span class="hljs-comment"># Buscar</span>
df[<span class="hljs-string">'tem_ana'</span>] = df[<span class="hljs-string">'nome'</span>].str.contains(<span class="hljs-string">'Ana'</span>)
df[<span class="hljs-string">'comeca_a'</span>] = df[<span class="hljs-string">'nome'</span>].str.startswith(<span class="hljs-string">'A'</span>)
df[<span class="hljs-string">'termina_o'</span>] = df[<span class="hljs-string">'nome'</span>].str.endswith(<span class="hljs-string">'o'</span>)

<span class="hljs-comment"># Extrair</span>
df[<span class="hljs-string">'primeira_letra'</span>] = df[<span class="hljs-string">'nome'</span>].str[<span class="hljs-number">0</span>]
df[<span class="hljs-string">'tres_primeiras'</span>] = df[<span class="hljs-string">'nome'</span>].str[:<span class="hljs-number">3</span>]

<span class="hljs-comment"># Split</span>
df[[<span class="hljs-string">'nome'</span>, <span class="hljs-string">'sobrenome'</span>]] = df[<span class="hljs-string">'nome_completo'</span>].str.split(<span class="hljs-string">' '</span>, expand=<span class="hljs-literal">True</span>)

<span class="hljs-comment"># Regex</span>
df[<span class="hljs-string">'email_valido'</span>] = df[<span class="hljs-string">'email'</span>].str.match(<span class="hljs-string">r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$'</span>)

<span class="hljs-comment"># Substituir</span>
df[<span class="hljs-string">'nome_corrigido'</span>] = df[<span class="hljs-string">'nome'</span>].str.replace(<span class="hljs-string">'João'</span>, <span class="hljs-string">'João Pedro'</span>)

<span class="hljs-comment"># Comprimento</span>
df[<span class="hljs-string">'tamanho_nome'</span>] = df[<span class="hljs-string">'nome'</span>].str.len()
</div></code></pre>
<hr>
<h2 id="5-visualiza%C3%A7%C3%A3o-de-dados">5. Visualização de Dados</h2>
<h3 id="51-princ%C3%ADpios-de-visualiza%C3%A7%C3%A3o">5.1 Princípios de Visualização</h3>
<p><strong>Por que visualizar:</strong></p>
<ol>
<li><strong>Comunicação:</strong> Transmitir informação complexa rapidamente</li>
<li><strong>Descoberta:</strong> Identificar padrões não óbvios</li>
<li><strong>Análise:</strong> Explorar relacionamentos</li>
<li><strong>Persuasão:</strong> Apoiar argumentos com evidências visuais</li>
</ol>
<p><strong>Princípios fundamentais:</strong></p>
<ol>
<li>
<p><strong>Clareza</strong></p>
<ul>
<li>Mensagem principal imediatamente aparente</li>
<li>Remover elementos desnecessários</li>
<li>Evitar chartjunk</li>
<li>Uma ideia por gráfico</li>
</ul>
</li>
<li>
<p><strong>Precisão</strong></p>
<ul>
<li>Representar dados fielmente</li>
<li>Não distorcer escalas</li>
<li>Começar eixo Y em zero (para barras)</li>
<li>Identificar outliers claramente</li>
</ul>
</li>
<li>
<p><strong>Eficiência</strong></p>
<ul>
<li>Escolher tipo certo de gráfico</li>
<li>Maximizar data-ink ratio</li>
<li>Usar cores com propósito</li>
<li>Ordenar categorias logicamente</li>
</ul>
</li>
<li>
<p><strong>Estética</strong></p>
<ul>
<li>Design agradável</li>
<li>Cores harmoniosas</li>
<li>Tipografia legível</li>
<li>Espaçamento adequado</li>
</ul>
</li>
</ol>
<p><strong>Data-Ink Ratio:</strong></p>
<p><strong>Definição:</strong> Proporção de tinta dedicada a mostrar dados vs. decoração.</p>
<p><strong>Objetivo:</strong> Maximizar informação, minimizar ruído.</p>
<p><strong>Como:</strong></p>
<ul>
<li>Remover gridlines desnecessárias</li>
<li>Simplificar eixos</li>
<li>Evitar 3D gratuito</li>
<li>Focar no conteúdo, não na forma</li>
</ul>
<h3 id="52-tipos-de-gr%C3%A1ficos">5.2 Tipos de Gráficos</h3>
<h4 id="compara%C3%A7%C3%A3o">Comparação</h4>
<p><strong>1. Gráfico de Barras</strong></p>
<p><strong>Definição:</strong> Barras retangulares com comprimentos proporcionais aos valores.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Comparar categorias</li>
<li>Mostrar ranking</li>
<li>Valores discretos</li>
<li>Poucas categorias (&lt; 15)</li>
</ul>
<p><strong>Quando NÃO usar:</strong></p>
<ul>
<li>Séries temporais (prefira linha)</li>
<li>Muitas categorias (&gt; 20)</li>
<li>Valores contínuos</li>
</ul>
<p><strong>Variações:</strong></p>
<ul>
<li>Vertical: Categorias no eixo X</li>
<li>Horizontal: Melhor para nomes longos</li>
<li>Agrupado: Comparar múltiplas séries</li>
<li>Empilhado: Mostrar composição</li>
</ul>
<p><strong>Boas práticas:</strong></p>
<ul>
<li>Sempre começar eixo Y em zero</li>
<li>Ordenar barras logicamente (valor, alfabético)</li>
<li>Usar cores consistentes</li>
<li>Adicionar valores nas barras se útil</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt

<span class="hljs-comment"># Gráfico de barras vertical</span>
categorias = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>]
valores = [<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>]

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.bar(categorias, valores, color=<span class="hljs-string">'steelblue'</span>, edgecolor=<span class="hljs-string">'black'</span>)
plt.xlabel(<span class="hljs-string">'Categoria'</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Comparação de Valores por Categoria'</span>)
plt.show()

<span class="hljs-comment"># Gráfico de barras horizontal</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.barh(categorias, valores, color=<span class="hljs-string">'coral'</span>)
plt.xlabel(<span class="hljs-string">'Valor'</span>)
plt.ylabel(<span class="hljs-string">'Categoria'</span>)
plt.title(<span class="hljs-string">'Ranking de Categorias'</span>)
plt.show()

<span class="hljs-comment"># Barras agrupadas</span>
x = np.arange(len(categorias))
valores1 = [<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>]
valores2 = [<span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>]
width = <span class="hljs-number">0.35</span>

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.bar(x - width/<span class="hljs-number">2</span>, valores1, width, label=<span class="hljs-string">'Série 1'</span>)
plt.bar(x + width/<span class="hljs-number">2</span>, valores2, width, label=<span class="hljs-string">'Série 2'</span>)
plt.xlabel(<span class="hljs-string">'Categoria'</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Comparação de Duas Séries'</span>)
plt.xticks(x, categorias)
plt.legend()
plt.show()
</div></code></pre>
<p><strong>2. Gráfico de Linha</strong></p>
<p><strong>Definição:</strong> Pontos conectados por linhas mostrando tendências.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Séries temporais</li>
<li>Mostrar tendências</li>
<li>Mudanças contínuas</li>
<li>Múltiplas séries relacionadas</li>
</ul>
<p><strong>Quando NÃO usar:</strong></p>
<ul>
<li>Dados categóricos não ordenados</li>
<li>Valores muito esparsos</li>
<li>Quando precisão exata é crítica</li>
</ul>
<p><strong>Boas práticas:</strong></p>
<ul>
<li>Tempo sempre no eixo X</li>
<li>Máximo 5-7 linhas</li>
<li>Cores distintas</li>
<li>Legendas claras</li>
<li>Marcar pontos importantes</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Série temporal simples</span>
datas = pd.date_range(<span class="hljs-string">'2024-01-01'</span>, periods=<span class="hljs-number">100</span>)
valores = np.cumsum(np.random.randn(<span class="hljs-number">100</span>)) + <span class="hljs-number">100</span>

plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))
plt.plot(datas, valores, linewidth=<span class="hljs-number">2</span>, color=<span class="hljs-string">'darkblue'</span>)
plt.xlabel(<span class="hljs-string">'Data'</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Evolução Temporal'</span>)
plt.grid(<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">0.3</span>)
plt.show()

<span class="hljs-comment"># Múltiplas séries</span>
plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))
plt.plot(datas, valores, label=<span class="hljs-string">'Série 1'</span>, linewidth=<span class="hljs-number">2</span>)
plt.plot(datas, valores * <span class="hljs-number">1.2</span>, label=<span class="hljs-string">'Série 2'</span>, linewidth=<span class="hljs-number">2</span>)
plt.plot(datas, valores * <span class="hljs-number">0.8</span>, label=<span class="hljs-string">'Série 3'</span>, linewidth=<span class="hljs-number">2</span>)
plt.xlabel(<span class="hljs-string">'Data'</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Comparação de Séries Temporais'</span>)
plt.legend()
plt.grid(<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">0.3</span>)
plt.show()
</div></code></pre>
<h4 id="distribui%C3%A7%C3%A3o">Distribuição</h4>
<p><strong>1. Histograma</strong></p>
<p><strong>Definição:</strong> Gráfico que mostra frequência de valores em intervalos (bins).</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Entender distribuição de variável contínua</li>
<li>Identificar forma da distribuição</li>
<li>Detectar outliers</li>
<li>Comparar com distribuições teóricas</li>
</ul>
<p><strong>Conceitos:</strong></p>
<ul>
<li><strong>Bins:</strong> Intervalos que agrupam valores</li>
<li><strong>Frequência:</strong> Contagem em cada bin</li>
<li><strong>Densidade:</strong> Frequência normalizada</li>
</ul>
<p><strong>Como escolher número de bins:</strong></p>
<ul>
<li>Regra de Sturges: k = 1 + log₂(n)</li>
<li>Regra de Rice: k = 2n^(1/3)</li>
<li>Teste visual: 10-30 bins geralmente funciona</li>
<li>Muito poucos: perde detalhe</li>
<li>Muito muitos: muito ruído</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Histograma básico</span>
dados = np.random.normal(<span class="hljs-number">100</span>, <span class="hljs-number">15</span>, <span class="hljs-number">1000</span>)

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.hist(dados, bins=<span class="hljs-number">30</span>, alpha=<span class="hljs-number">0.7</span>, color=<span class="hljs-string">'skyblue'</span>, edgecolor=<span class="hljs-string">'black'</span>)
plt.axvline(np.mean(dados), color=<span class="hljs-string">'red'</span>, linestyle=<span class="hljs-string">'--'</span>,
            linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">f'Média: <span class="hljs-subst">{np.mean(dados):<span class="hljs-number">.2</span>f}</span>'</span>)
plt.axvline(np.median(dados), color=<span class="hljs-string">'green'</span>, linestyle=<span class="hljs-string">'--'</span>,
            linewidth=<span class="hljs-number">2</span>, label=<span class="hljs-string">f'Mediana: <span class="hljs-subst">{np.median(dados):<span class="hljs-number">.2</span>f}</span>'</span>)
plt.xlabel(<span class="hljs-string">'Valor'</span>)
plt.ylabel(<span class="hljs-string">'Frequência'</span>)
plt.title(<span class="hljs-string">'Distribuição de Valores'</span>)
plt.legend()
plt.show()

<span class="hljs-comment"># Densidade</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.hist(dados, bins=<span class="hljs-number">30</span>, density=<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">0.7</span>, color=<span class="hljs-string">'lightgreen'</span>)
plt.xlabel(<span class="hljs-string">'Valor'</span>)
plt.ylabel(<span class="hljs-string">'Densidade'</span>)
plt.title(<span class="hljs-string">'Distribuição (Densidade)'</span>)
plt.show()
</div></code></pre>
<p><strong>2. Box Plot</strong></p>
<p><strong>Definição:</strong> Visualização que mostra quartis, mediana e outliers.</p>
<p><strong>Componentes:</strong></p>
<ul>
<li><strong>Caixa:</strong> Q1 a Q3 (IQR)</li>
<li><strong>Linha central:</strong> Mediana</li>
<li><strong>Whiskers:</strong> 1.5 * IQR</li>
<li><strong>Pontos:</strong> Outliers</li>
</ul>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Comparar distribuições</li>
<li>Identificar outliers</li>
<li>Ver assimetria</li>
<li>Resumo compacto de distribuição</li>
</ul>
<p><strong>Interpretação:</strong></p>
<ul>
<li>Caixa grande: Alta dispersão</li>
<li>Mediana não centralizada: Assimétrica</li>
<li>Whiskers longos: Cauda longa</li>
<li>Muitos pontos: Muitos outliers</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Box plot único</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.boxplot(dados, vert=<span class="hljs-literal">True</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Box Plot da Distribuição'</span>)
plt.show()

<span class="hljs-comment"># Box plots comparativos</span>
dados_grupos = [
    np.random.normal(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>),
    np.random.normal(<span class="hljs-number">110</span>, <span class="hljs-number">15</span>, <span class="hljs-number">100</span>),
    np.random.normal(<span class="hljs-number">90</span>, <span class="hljs-number">12</span>, <span class="hljs-number">100</span>)
]

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.boxplot(dados_grupos, labels=[<span class="hljs-string">'Grupo A'</span>, <span class="hljs-string">'Grupo B'</span>, <span class="hljs-string">'Grupo C'</span>])
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Comparação de Distribuições entre Grupos'</span>)
plt.show()
</div></code></pre>
<p><strong>3. Violin Plot</strong></p>
<p><strong>Definição:</strong> Combina box plot com kernel density estimation.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Mostrar distribuição completa</li>
<li>Identificar multimodalidade</li>
<li>Comparar grupos</li>
<li>Quando box plot perde informação</li>
</ul>
<p><strong>Vantagens sobre box plot:</strong></p>
<ul>
<li>Mostra forma completa da distribuição</li>
<li>Revela múltiplos picos</li>
<li>Mais informação visual</li>
</ul>
<p><strong>Desvantagens:</strong></p>
<ul>
<li>Mais complexo de interpretar</li>
<li>Requer mais dados</li>
<li>Pode confundir audiência não técnica</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
sns.violinplot(data=[dados_grupos[<span class="hljs-number">0</span>], dados_grupos[<span class="hljs-number">1</span>], dados_grupos[<span class="hljs-number">2</span>]])
plt.xlabel(<span class="hljs-string">'Grupo'</span>)
plt.ylabel(<span class="hljs-string">'Valor'</span>)
plt.title(<span class="hljs-string">'Violin Plot - Comparação de Distribuições'</span>)
plt.show()
</div></code></pre>
<h4 id="rela%C3%A7%C3%A3o">Relação</h4>
<p><strong>1. Scatter Plot</strong></p>
<p><strong>Definição:</strong> Pontos representando pares de valores de duas variáveis.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Explorar relação entre variáveis</li>
<li>Identificar correlação</li>
<li>Detectar clusters</li>
<li>Identificar outliers bivariados</li>
</ul>
<p><strong>Interpretação:</strong></p>
<ul>
<li><strong>Positiva:</strong> Pontos sobem da esquerda para direita</li>
<li><strong>Negativa:</strong> Pontos descem da esquerda para direita</li>
<li><strong>Sem relação:</strong> Pontos espalhados aleatoriamente</li>
<li><strong>Não-linear:</strong> Padrão curvo</li>
</ul>
<p><strong>Elementos adicionais:</strong></p>
<ul>
<li><strong>Tamanho:</strong> Terceira variável</li>
<li><strong>Cor:</strong> Quarta variável (categórica)</li>
<li><strong>Linha de tendência:</strong> Mostrar relação</li>
<li><strong>Transparência:</strong> Lidar com sobreposição</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Scatter básico</span>
x = np.random.randn(<span class="hljs-number">100</span>)
y = <span class="hljs-number">2</span>*x + np.random.randn(<span class="hljs-number">100</span>)*<span class="hljs-number">0.5</span>

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.scatter(x, y, alpha=<span class="hljs-number">0.6</span>)
plt.xlabel(<span class="hljs-string">'X'</span>)
plt.ylabel(<span class="hljs-string">'Y'</span>)
plt.title(<span class="hljs-string">'Scatter Plot - Relação entre X e Y'</span>)
plt.grid(<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">0.3</span>)
plt.show()

<span class="hljs-comment"># Com cor e tamanho</span>
tamanhos = np.random.randint(<span class="hljs-number">20</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>)
cores = np.random.randn(<span class="hljs-number">100</span>)

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
scatter = plt.scatter(x, y, s=tamanhos, c=cores, cmap=<span class="hljs-string">'viridis'</span>, alpha=<span class="hljs-number">0.6</span>)
plt.colorbar(scatter, label=<span class="hljs-string">'Terceira variável'</span>)
plt.xlabel(<span class="hljs-string">'X'</span>)
plt.ylabel(<span class="hljs-string">'Y'</span>)
plt.title(<span class="hljs-string">'Scatter Plot com 4 Variáveis'</span>)
plt.show()

<span class="hljs-comment"># Com linha de regressão</span>
<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats
slope, intercept, r_value, p_value, std_err = stats.linregress(x, y)

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.scatter(x, y, alpha=<span class="hljs-number">0.6</span>, label=<span class="hljs-string">'Dados'</span>)
plt.plot(x, slope*x + intercept, <span class="hljs-string">'r'</span>, linewidth=<span class="hljs-number">2</span>,
         label=<span class="hljs-string">f'Regressão (R²=<span class="hljs-subst">{r_value**<span class="hljs-number">2</span>:<span class="hljs-number">.3</span>f}</span>)'</span>)
plt.xlabel(<span class="hljs-string">'X'</span>)
plt.ylabel(<span class="hljs-string">'Y'</span>)
plt.title(<span class="hljs-string">'Scatter Plot com Linha de Regressão'</span>)
plt.legend()
plt.grid(<span class="hljs-literal">True</span>, alpha=<span class="hljs-number">0.3</span>)
plt.show()
</div></code></pre>
<p><strong>2. Heatmap</strong></p>
<p><strong>Definição:</strong> Matriz de valores representados por cores.</p>
<p><strong>Quando usar:</strong></p>
<ul>
<li>Visualizar matriz de correlação</li>
<li>Mostrar padrões em tabela</li>
<li>Comparar múltiplas dimensões</li>
<li>Identificar clusters</li>
</ul>
<p><strong>Escolha de cores:</strong></p>
<ul>
<li><strong>Sequencial:</strong> Uma cor, dados ordenados</li>
<li><strong>Divergente:</strong> Duas cores, ponto central importante</li>
<li><strong>Qualitativa:</strong> Categorias</li>
</ul>
<p><strong>Boas práticas:</strong></p>
<ul>
<li>Incluir valores nas células se legíveis</li>
<li>Escala de cores apropriada</li>
<li>Ordenar linhas/colunas logicamente</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Heatmap de correlação</span>
df = pd.DataFrame(np.random.randn(<span class="hljs-number">100</span>, <span class="hljs-number">5</span>), columns=list(<span class="hljs-string">'ABCDE'</span>))
correlacao = df.corr()

plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))
sns.heatmap(correlacao, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">'coolwarm'</span>, center=<span class="hljs-number">0</span>,
            square=<span class="hljs-literal">True</span>, linewidths=<span class="hljs-number">1</span>, cbar_kws={<span class="hljs-string">"shrink"</span>: <span class="hljs-number">0.8</span>})
plt.title(<span class="hljs-string">'Matriz de Correlação'</span>)
plt.show()

<span class="hljs-comment"># Heatmap de dados</span>
dados_matriz = np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">12</span>)

plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>))
sns.heatmap(dados_matriz, annot=<span class="hljs-literal">True</span>, fmt=<span class="hljs-string">'.2f'</span>, cmap=<span class="hljs-string">'YlOrRd'</span>)
plt.title(<span class="hljs-string">'Heatmap de Valores'</span>)
plt.show()
</div></code></pre>
<h4 id="composi%C3%A7%C3%A3o">Composição</h4>
<p><strong>1. Gráfico de Pizza</strong></p>
<p><strong>Definição:</strong> Círculo dividido em fatias proporcionais.</p>
<p><strong>Quando usar (com MUITO cuidado):</strong></p>
<ul>
<li>Mostrar partes de um todo</li>
<li>Poucas categorias (2-5)</li>
<li>Uma categoria claramente dominante</li>
<li>Audiência geral</li>
</ul>
<p><strong>Quando NÃO usar:</strong></p>
<ul>
<li>Mais de 5 categorias</li>
<li>Valores similares</li>
<li>Comparações precisas necessárias</li>
<li>Múltiplas séries</li>
</ul>
<p><strong>Alternativas melhores:</strong></p>
<ul>
<li>Gráfico de barras</li>
<li>Treemap</li>
<li>Waffle chart</li>
</ul>
<p><strong>Se usar pizza:</strong></p>
<ul>
<li>Ordenar fatias (maior para menor)</li>
<li>Começar às 12h</li>
<li>Limitar a 5 fatias</li>
<li>Considerar donut chart</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Pizza básica (use com moderação!)</span>
categorias = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>]
valores = [<span class="hljs-number">35</span>, <span class="hljs-number">25</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>]

plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))
plt.pie(valores, labels=categorias, autopct=<span class="hljs-string">'%1.1f%%'</span>, startangle=<span class="hljs-number">90</span>)
plt.title(<span class="hljs-string">'Distribuição por Categoria'</span>)
plt.axis(<span class="hljs-string">'equal'</span>)
plt.show()

<span class="hljs-comment"># Melhor alternativa: barras horizontais</span>
plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))
plt.barh(categorias, valores)
plt.xlabel(<span class="hljs-string">'Valor'</span>)
plt.ylabel(<span class="hljs-string">'Categoria'</span>)
plt.title(<span class="hljs-string">'Distribuição por Categoria (Alternativa Melhor)'</span>)
plt.show()
</div></code></pre>
<h3 id="53-cores-em-visualiza%C3%A7%C3%B5es">5.3 Cores em Visualizações</h3>
<p><strong>Teoria das cores:</strong></p>
<p><strong>Tipos de escalas:</strong></p>
<ol>
<li>
<p><strong>Sequencial</strong></p>
<ul>
<li><strong>Quando:</strong> Dados ordenados, mesma variável</li>
<li><strong>Exemplos:</strong> Temperatura, idade, renda</li>
<li><strong>Paletas:</strong> Blues, Greens, Reds</li>
</ul>
</li>
<li>
<p><strong>Divergente</strong></p>
<ul>
<li><strong>Quando:</strong> Ponto central importante, desvios</li>
<li><strong>Exemplos:</strong> Correlação, diferença, mudança</li>
<li><strong>Paletas:</strong> RdBu, RdYlGn, PiYG</li>
</ul>
</li>
<li>
<p><strong>Qualitativa</strong></p>
<ul>
<li><strong>Quando:</strong> Categorias distintas</li>
<li><strong>Exemplos:</strong> Tipos, grupos, regiões</li>
<li><strong>Paletas:</strong> Set1, Set2, Paired</li>
</ul>
</li>
</ol>
<p><strong>Acessibilidade:</strong></p>
<ul>
<li>Evitar apenas vermelho-verde (daltonismo)</li>
<li>Testar em escala de cinza</li>
<li>Usar padrões além de cores</li>
<li>Incluir legendas claras</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Sequencial</span>
plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">4</span>))
<span class="hljs-keyword">for</span> i, cmap <span class="hljs-keyword">in</span> enumerate([<span class="hljs-string">'Blues'</span>, <span class="hljs-string">'Greens'</span>, <span class="hljs-string">'Oranges'</span>], <span class="hljs-number">1</span>):
    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, i)
    data = np.random.rand(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
    plt.imshow(data, cmap=cmap)
    plt.colorbar()
    plt.title(<span class="hljs-string">f'Sequencial: <span class="hljs-subst">{cmap}</span>'</span>)
plt.tight_layout()
plt.show()

<span class="hljs-comment"># Divergente</span>
plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">4</span>))
<span class="hljs-keyword">for</span> i, cmap <span class="hljs-keyword">in</span> enumerate([<span class="hljs-string">'RdBu'</span>, <span class="hljs-string">'RdYlGn'</span>, <span class="hljs-string">'PiYG'</span>], <span class="hljs-number">1</span>):
    plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, i)
    data = np.random.randn(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)
    plt.imshow(data, cmap=cmap, vmin=<span class="hljs-number">-3</span>, vmax=<span class="hljs-number">3</span>)
    plt.colorbar()
    plt.title(<span class="hljs-string">f'Divergente: <span class="hljs-subst">{cmap}</span>'</span>)
plt.tight_layout()
plt.show()
</div></code></pre>
<hr>

</body>
</html>
